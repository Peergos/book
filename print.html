<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="overview/overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><a href="features/features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li><ol class="section"><li><a href="features/self.html"><strong aria-hidden="true">2.1.</strong> Self hosting</a></li><li><a href="features/p2p.html"><strong aria-hidden="true">2.2.</strong> Peer-to-peer</a></li><li><a href="features/trust.html"><strong aria-hidden="true">2.3.</strong> Trust free server</a></li><li><a href="features/multi.html"><strong aria-hidden="true">2.4.</strong> Multi-device login</a></li><li><a href="features/web.html"><strong aria-hidden="true">2.5.</strong> Web interface</a></li><li><a href="features/social.html"><strong aria-hidden="true">2.6.</strong> Social</a></li><li><a href="features/sharing.html"><strong aria-hidden="true">2.7.</strong> Sharing</a></li><li><a href="features/large.html"><strong aria-hidden="true">2.8.</strong> Large files</a></li><li><a href="features/streaming.html"><strong aria-hidden="true">2.9.</strong> Streaming</a></li><li><a href="features/viewers.html"><strong aria-hidden="true">2.10.</strong> File viewers</a></li><li><a href="features/secret.html"><strong aria-hidden="true">2.11.</strong> Secret links</a></li><li><a href="features/migration.html"><strong aria-hidden="true">2.12.</strong> Migration</a></li><li><a href="features/sync.html"><strong aria-hidden="true">2.13.</strong> File Sync</a></li><li><a href="features/open.html"><strong aria-hidden="true">2.14.</strong> Open source</a></li></ol></li><li><a href="architecture/architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li><ol class="section"><li><a href="architecture/logical.html"><strong aria-hidden="true">3.1.</strong> Logical</a></li><li><a href="architecture/physical.html"><strong aria-hidden="true">3.2.</strong> Physical</a></li><li><a href="architecture/immutable.html"><strong aria-hidden="true">3.3.</strong> Immutable data</a></li><li><a href="architecture/mutable.html"><strong aria-hidden="true">3.4.</strong> Mutable pointers</a></li><li><a href="architecture/writer.html"><strong aria-hidden="true">3.5.</strong> Writing subspaces</a></li><li><a href="architecture/champ.html"><strong aria-hidden="true">3.6.</strong> Merkle-CHAMP</a></li><li><a href="architecture/pki.html"><strong aria-hidden="true">3.7.</strong> Usernames</a></li><li><a href="architecture/follow.html"><strong aria-hidden="true">3.8.</strong> Follow requests</a></li></ol></li><li><a href="security/security.html"><strong aria-hidden="true">4.</strong> Security</a></li><li><ol class="section"><li><a href="security/trust.html"><strong aria-hidden="true">4.1.</strong> Trust free layers</a></li><li><a href="security/threats.html"><strong aria-hidden="true">4.2.</strong> Threat models</a></li><li><a href="security/login.html"><strong aria-hidden="true">4.3.</strong> Login</a></li><li><a href="security/encryption.html"><strong aria-hidden="true">4.4.</strong> Encryption</a></li><li><a href="security/cryptree.html"><strong aria-hidden="true">4.5.</strong> Access control</a></li><li><a href="security/meta.html"><strong aria-hidden="true">4.6.</strong> Metadata</a></li><li><a href="security/quantum.html"><strong aria-hidden="true">4.7.</strong> Quantum resistance</a></li><li><a href="security/social.html"><strong aria-hidden="true">4.8.</strong> Social graph</a></li><li><a href="security/pki.html"><strong aria-hidden="true">4.9.</strong> PKI</a></li></ol></li><li><a href="dev/details.html"><strong aria-hidden="true">5.</strong> How does it work?</a></li><li><ol class="section"><li><a href="dev/signup.html"><strong aria-hidden="true">5.1.</strong> Signing up</a></li><li><a href="dev/upload.html"><strong aria-hidden="true">5.2.</strong> Uploading a file</a></li><li><a href="dev/follow.html"><strong aria-hidden="true">5.3.</strong> Sending a follow request</a></li><li><a href="dev/proxy.html"><strong aria-hidden="true">5.4.</strong> Proxying requests</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#peergos---your-private-online-space" id="peergos---your-private-online-space"><h1>Peergos - your private online space</h1></a>
<p>Peergos is building the next web - the private web, where end users are in control. Imagine web apps being secure by default and unable to track you. Imagine being able to control exactly what personal data each web app can see. Imagine never having to log in to an app ever again. You own your data and decide where it is stored and who can see it. At Peergos, we believe that privacy is a fundamental human right and we want to make it easy for everyone to interact online in ways that respect this right.</p>
<p>Peergos is a peer-to-peer encrypted global filesystem with fine grained access control designed to be resistant to surveillance of data content or friendship graphs. It will have a secure email replacement, with some interoperability with email. There will also be a totally private and secure social network, where users are in control of who sees what (executed cryptographically).</p>
<p>The name Peergos comes from the Greek word Πύργος (Pyrgos), which means stronghold or tower, but phonetically spelt with the nice connection to being peer-to-peer. It is pronounced peer-goss, as in gossip.</p>
<p><strong>WARNING:</strong> Peergos has had an audit by Cure53, but is still in active development. Some of the features in this documentation are yet to be implemented, in particular, Tor is not used yet.</p>
<a class="header" href="#aims" id="aims"><h2>Aims</h2></a>
<ul>
<li><strong>Securely</strong> and <strong>privately</strong> store files in a peer to peer network which has no central node and is generally difficult to disrupt or surveil</li>
<li><strong>Secure sharing</strong> of such files with other users of the network without visible meta-data (who shares with who)</li>
<li><strong>Trust free</strong> servers and storage. Clients do not need to trust their server or storage. Data, metadata, and contact lists are never exposed to your server.</li>
<li><strong>Beautiful user interface</strong> that any computer or mobile user can understand</li>
<li><strong>Secure messaging</strong>, with optional interop with actual email</li>
<li><strong>Independent</strong> of the central SSL CA trust architecture, and the domain name system</li>
<li><strong>Self hostable</strong> - A user should be able to easily run Peergos on a machine in their home and get their own Peergos storage space, and social communication platform from it</li>
<li>Secure web interface as well as desktop clients, native folder sync, and a command line interface</li>
<li>Do not rely on any cryptocurrency</li>
<li>Enable users to collaborate, editing a document in place concurrently</li>
<li>Secure real time chat, and video conferencing able to handle 100s of participants, fully end-to-end encrypted</li>
<li>Social account recovery - designate N of M friends who can collaborate to recover your account if you lose your password</li>
<li>Optional use of U2F for securing login</li>
</ul>
<a class="header" href="#features" id="features"><h1>Features</h1></a>
<ul>
<li>Self hosting</li>
<li>Peer-to-peer</li>
<li>Multi-device login</li>
<li>Web interface</li>
<li>Social</li>
<li>Sharing</li>
<li>Large files</li>
<li>Streaming</li>
<li>File viewers</li>
<li>Public links</li>
<li>Migration</li>
<li>Folder Sync</li>
<li>Open source</li>
</ul>
<a class="header" href="#self-hosting" id="self-hosting"><h1>Self hosting</h1></a>
<p>Peergos is fully self hostable. You can run peergos from your own home or server to obtain as much storage and bandwidth as you need, whilst still transparently interacting with anyone using any other server. Because the server only ever sees encrypted data you can also tell it to directly store your data in a standard cloud storage provider like Backblaze or Amazon without any loss of privacy.</p>
<p><img alt="Self host at home or on your own server" src="/img/self-host.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#peer-to-peer" id="peer-to-peer"><h1>Peer-to-peer</h1></a>
<p>Peergos is built with a peer-to-peer architecture to protect against censorship and surveillance and to improve resiliency. There is no central surveillance point that an attacker could monitor all file transfers through. There is also no central dns name or TLS certificate authority that could be used to attack the network.</p>
<p><img alt="Peergos has a peer-to-peer architecture" src="/img/p2p.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#trust-free-servers" id="trust-free-servers"><h1>Trust free servers</h1></a>
<p>Peergos is designed so that clients do no need to trust the Peergos server they are talking to. Hashes and signatures are all verified client side for reads and writes. Data can also be mirrored to transparently provide redundancy. </p>
<a class="header" href="#multi-device-login" id="multi-device-login"><h1>Multi-device login</h1></a>
<p>Peergos is naturally mutli-device. You can log in to your account from any device, and through any Peergos server. It is not tied to any other data like your phone number or email address. All you need is your username and your password. Any modern browser will suffice, including mobile.</p>
<p><img alt="Login through any device with a web browser" src="/img/multi-device.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#web-interface" id="web-interface"><h1>Web interface</h1></a>
<p>In keeping with our aim to be as convenient to use as existing centralised services, Peergos has a web interface which can be used instead of a native application. This interface does not require any special knowledge, especially not of cryptography or keys, but should none-the-less encourage/enforce safe practices. The web interface does not load any code from third-party servers and is entirely self hosted. You even load it directly from ipfs and log in!</p>
<p>The web interface can be accessed from a public server over https or from your machine if you run Peergos locally. </p>
<a class="header" href="#social" id="social"><h1>Social</h1></a>
<p>Peergos users can send follow requests to each other. If accepted, the other user can then share files or send messages with you. Following is a one-way mechanism: If Agata follows Bartek then Bartek can share files with Agata. If Bartek is also following Agata, then she can also share files with Bartek. Following can be revoked by either user at any point.</p>
<p>Your friend list is kept encrypted in your own Peergos space, hidden from other users and the server.</p>
<p>There is also a public link mechanism for sharing files with people who do not have peergos accounts. </p>
<a class="header" href="#sharing" id="sharing"><h1>Sharing</h1></a>
<p>A file or folder can be shared with any user who is following you. This access can be read only or writable. Access can be revoked at any time whilst maintaining access to anyone else the item is shared with. This is all achieved cryptographically with capabilities and lazy re-encryption. </p>
<a class="header" href="#large-files" id="large-files"><h1>Large files</h1></a>
<p>There is no file size limit in Peergos apart from what will fit in your storage quota. Despite doing client side encryption/decryption we can still upload or download arbitrarily large files sending directly from/to the filesystem. </p>
<a class="header" href="#streaming" id="streaming"><h1>Streaming</h1></a>
<p>Peergos is naturally streaming and despite having to decrypt files in the client we can still stream large files directly with low ram usage. This allows us to stream large videos in the browser directly to a html5 video element. </p>
<a class="header" href="#file-viewers" id="file-viewers"><h1>File viewers</h1></a>
<p>There are several built-in file viewers in Peergos. We have viewers for the following file types:</p>
<ul>
<li>images</li>
<li>videos</li>
<li>audio</li>
<li>pdf</li>
<li>binary (hex viewer)</li>
</ul>
<p>We have editors for the following formats</p>
<ul>
<li>text</li>
<li>markdown</li>
<li>code</li>
</ul>
<p>We support the following languages in the code editor:</p>
<ul>
<li>c</li>
<li>c++</li>
<li>Clojure</li>
<li>css</li>
<li>diff</li>
<li>Go</li>
<li>html</li>
<li>Java</li>
<li>Javascript</li>
<li>Kotlin</li>
<li>python</li>
<li>Ruby</li>
<li>Rust</li>
<li>Scala</li>
<li>shell</li>
<li>tex</li>
<li>xml</li>
<li>yaml</li>
</ul>
<a class="header" href="#secret-links" id="secret-links"><h1>Secret links</h1></a>
<p>A secret link can be generated to point to any file or folder. Anyone with a (Javascript enabled) web browser can view such a link. This is a capability based link which includes the necessary key in the hash fragment of the url. A secret link doesn't expose the file to the network, or indeed to anyone who doesn't have the link itself because the key material isn't sent to the server.</p>
<p>An example of a secret link to a folder is:</p>
<p><a href="https://demo.peergos.net/#6MDZhRRPT4ugkJuUfcPPhf1US9u7FvRALmj42mJ6e3yDibnLtqfhchE6Frm6Lf/6MDZhRRPT4ugkJuUfcZdxu6JLKyrLBE36Kasxb4jix7An4dbeiekpDF6h2fDBM/HUja6zmXVs24zcRf15s1MWB7kfvyTCp2X9NF4EZqcw7/5Pf7SvCKyBYfP1vm5LfTSw8TMHtLWvJDLv1P4QtCXV8P2Zv8FwR">https://demo.peergos.net/#6MDZhRRPT4ugkJuUfcPPhf1US9u7FvRALmj42mJ6e3yDibnLtqfhchE6Frm6Lf/6MDZhRRPT4ugkJuUfcZdxu6JLKyrLBE36Kasxb4jix7An4dbeiekpDF6h2fDBM/HUja6zmXVs24zcRf15s1MWB7kfvyTCp2X9NF4EZqcw7/5Pf7SvCKyBYfP1vm5LfTSw8TMHtLWvJDLv1P4QtCXV8P2Zv8FwR</a></p>
<a class="header" href="#migration" id="migration"><h1>Migration</h1></a>
<p>Your identity in Peergos is not tied to any particular server. Compared to other federated social networks where moving server typically involves losing your social network and meta-data, if not data too, Peergos allows you to transparently migrate between servers and storage providers without any action required from your friends and without any data loss.</p>
<p>This means, for example, you could start out by creating an account on our demo server which gives you a small amount of storage, then effortlessly migrate to a paid server, or to your own server when you realise how awesome Peergos is. </p>
<a class="header" href="#file-sync" id="file-sync"><h1>File Sync</h1></a>
<p>Peergos has the ability to do standard directory syncing and transparently mount a folder to your host operating system. This is achieved with a FUSE binding (or equivalent for Windows and MacOS). </p>
<a class="header" href="#open-source" id="open-source"><h1>Open source</h1></a>
<p>Peergos is fully open-source, both clients, and server (incuding the web-interface). The main interface is a web-ui, but Peergos can also be accessed using a Java client on the command line, or with a FUSE mount of your Peergos filesystem.</p>
<p>No part of our infrastructure, apart from TLS and Peergos private keys, are secret. We also have reproducible builds (we don't use npm or browserify etc.) We also vendor all dependencies so any historic git commit should be buildable without any external data.</p>
<p>Eventually we want to self host our git repos in Peergos itself. </p>
<a class="header" href="#peergos-architecture" id="peergos-architecture"><h1>Peergos architecture</h1></a>
<a class="header" href="#logical" id="logical"><h1>Logical</h1></a>
<p>The logical architecture of Peergos consists of the following:</p>
<ol>
<li>Content addressed storage: a data store with a mapping from the hash of a block of data to the data itself</li>
<li>Mutable pointers: a mapping from a public key to a hash</li>
<li>PKI: a global append only log for the username &lt;==&gt; {identity public key, storage public key} mappings</li>
<li>Social: each user designates a server for sending follow requests for users to (the server can't see the source user). This is the same as the storage server for that user and is identified and contacted via its public key.</li>
</ol>
<p><img alt="Logical Architecture" src="/img/logical-arch.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#physical" id="physical"><h1>Physical</h1></a>
<p>Each user must have at least one Peergos server (which includes an instance of IPFS). This server stores their data, their mutable pointers and any pending follow requests for them. There is also the global append only log for the PKI which is mirrored on every node. Communication between IPFS instances is done over encrypted secio streams. <a href="https://github.com/libp2p/go-libp2p-secio">secio</a> is like TLS but with a different handshake.</p>
<p><img alt="The physical architecture" src="/img/physical-arch.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#immutable-data" id="immutable-data"><h1>Immutable data</h1></a>
<p>The immutable data store is provided by IPFS and allows anyone to retrieve any cipher text from its hash through any Peergos node. Note that IPFS is used in a fully trustless manner. Every single hash and signature is checked client side during reads and writes. The underlying storage can be provided by the local harddisk or any cloud provider without loss of privacy.</p>
<p>The interface for this storage is call ContentAddressedStorage, with the following methods:</p>
<pre><code class="language-java">/**
 *
 * @return The identity (hash of the public key) of the storage node we are talking to
 */
CompletableFuture&lt;Multihash&gt; id();

/**
 *
 * @param owner
 * @return A new transaction id that can be used to group writes together and protect them from being garbage
 * collected before they have been pinned.
 */
CompletableFuture&lt;TransactionId&gt; startTransaction(PublicKeyHash owner);

/**
 * Release all associated objects from this transaction to allow them to be garbage collected if they haven't been
 * pinned.
 * owner
 * @param tid
 * @return
 */
CompletableFuture&lt;Boolean&gt; closeTransaction(PublicKeyHash owner, TransactionId tid);

/**
 *
 * @param owner The owner of these blocks of data
 * @param writer The public signing key authorizing these writes, which must be owned by the owner key
 * @param signatures The signatures of each block being written (by the writer)
 * @param blocks The blocks to write
 * @param tid The transaction to group these writes under
 * @return
 */
CompletableFuture&lt;List&lt;Multihash&gt;&gt; put(PublicKeyHash owner, PublicKeyHash writer, List&lt;byte[]&gt; signatures, List&lt;byte[]&gt; blocks, TransactionId tid);

/**
 *
 * @param hash
 * @return The data with the requested hash, deserialized into cbor, or Optional.empty() if no object can be found
 */
CompletableFuture&lt;Optional&lt;CborObject&gt;&gt; get(Multihash hash);

/**
 * Write a block of data that is just raw bytes, not ipld structured cbor
 * @param owner
 * @param writer
 * @param signatures
 * @param blocks
 * @param tid
 * @return
 */
CompletableFuture&lt;List&lt;Multihash&gt;&gt; putRaw(PublicKeyHash owner, PublicKeyHash writer, List&lt;byte[]&gt; signatures, List&lt;byte[]&gt; blocks, TransactionId tid);

/**
 * Get a block of data that is not in ipld cbor format, just raw bytes
 * @param hash
 * @return
 */
CompletableFuture&lt;Optional&lt;byte[]&gt;&gt; getRaw(Multihash hash);

/**
 * Update an existing pin with a new root. This is useful when modifying a tree of ipld objects where only a small
 * number of components are changed
 * @param owner The owner of the data
 * @param existing The present root hash
 * @param updated The new root hash
 * @return
 */
CompletableFuture&lt;List&lt;MultiAddress&gt;&gt; pinUpdate(PublicKeyHash owner, Multihash existing, Multihash updated);

/**
 * Recursively pin all the objects referenced via ipld merkle links from a root object
 * @param owner The owner of the data
 * @param hash The root hash of the merkle-tree
 * @return A list of the multihashes pinned
 */
CompletableFuture&lt;List&lt;Multihash&gt;&gt; recursivePin(PublicKeyHash owner, Multihash hash);

/**
 * Recursively unpin a merkle tree of objects. This releases the objects to be collected by garbage collection
 * @param owner The owner of the data
 * @param hash The root hash of the merkle-tree
 * @return
 */
CompletableFuture&lt;List&lt;Multihash&gt;&gt; recursiveUnpin(PublicKeyHash owner, Multihash hash);

/**
 * Get all the merkle-links referenced directly from this object
 * @param root The hash of the object whose links we want
 * @return A list of the multihashes referenced with ipld links in this object
 */
CompletableFuture&lt;List&lt;Multihash&gt;&gt; getLinks(Multihash root);

/**
 * Get the size in bytes of the object with the requested hash
 * @param block The hash of the object
 * @return The size in bytes, or Optional.empty() if it cannot be found.
 */
CompletableFuture&lt;Optional&lt;Integer&gt;&gt; getSize(Multihash block);
</code></pre>
<a class="header" href="#mutable" id="mutable"><h1>Mutable</h1></a>
<p>Mutable pointers in Peergos are just a mapping from a public key to a root hash. Clearly, being mutable, they need some kind of synchronization or concurrent data structure. Each user lists an ipfs node id (the hash of its public key) which is responsible for synchronising their writes and publishing the latest root hashes. This means the global filesystem is sharded by username and each user can use an ipfs instance (or cluster) with sufficient capability for their bandwidth requirements.</p>
<p>Initially each user's file system is under a single public key. Additional keys are generated when granting write access.</p>
<p>The interface for MutablePointers has the following methods:</p>
<pre><code class="language-java">/** Update the hash that a public key maps to (doing a cas with the existing value)
 *
 * @param owner The owner of this signing key
 * @param writer The public signing key
 * @param writerSignedBtreeRootHash the signed serialization of the HashCasPair
 * @return True when sucessfully completed
 */
CompletableFuture&lt;Boolean&gt; setPointer(PublicKeyHash owner, PublicKeyHash writer, byte[] writerSignedBtreeRootHash);

/** Get the current hash a public key maps to
 *
 * @param writer The public signing key
 * @return The signed cas of the pointer from its previous value to its current value
 */
CompletableFuture&lt;Optional&lt;byte[]&gt;&gt; getPointer(PublicKeyHash owner, PublicKeyHash writer);
</code></pre>
<a class="header" href="#writing-subspaces" id="writing-subspaces"><h1>Writing subspaces</h1></a>
<p>Each user has a randomly generated writing key pair which controls writes to their filesystem. They can create new writing key pairs for any subtree, for example when granting write access to a file or folder. If desired, a given writing key can be quota controlled, to prevent users to which you've granted write access to a file from filling your data store.</p>
<p>Every signing keypair, including your identity keypair, and your root writing keypair, map to a data structure called WriterData. A WriterData can contain merkle links to roots of merkle champs and various public keys. The full data structure is listed below. If any of the properties are empty they do not contribute to the size of the serialized WriterData.</p>
<pre><code class="language-java">// the public signing key controlling this subspace
PublicKeyHash controller;

// publicly readable and present on owner keys
Optional&lt;SecretGenerationAlgorithm&gt; generationAlgorithm;

// This is the root of a champ containing publicly shared files and folders (a lookup from path to capability)
Optional&lt;Multihash&gt; publicData;

// The public boxing key to encrypt follow requests to
Optional&lt;PublicKeyHash&gt; followRequestReceiver;

// Any keys directly owned by the controller, that aren't named
Set&lt;PublicKeyHash&gt; ownedKeys;

// Any keys directly owned by the controller that have specific labels
Map&lt;String, PublicKeyHash&gt; namedOwnedKeys;

// Encrypted entry points to our and our friends file systems (present on owner keys)
Optional&lt;UserStaticData&gt; staticData;

// This is the root of a champ containing the controller's filesystem (present on writer keys)
Optional&lt;Multihash&gt; tree;
</code></pre>
<a class="header" href="#merkle-champ" id="merkle-champ"><h1>Merkle-CHAMP</h1></a>
<p>The main network visible data structure in Peergos is a merkle compressed hash array mapped trie, or merkle-champ. This data structure is explained in the next section. All the data under a given writing keypair has its own merkle-champ. This is just a mapping from random 32 byte labels to cipher-text blobs. These blobs are <a href="/security/cryptree.html">cryptree</a> nodes containing the cryptree data structure, and, in the case of a file section, merkle links to encrypted file fragments. A merkle-link is just a hash that references another ipfs object. Each 5 MiB section of a file is stored under a different random label in the btree, and similarly with large directories.</p>
<p><img alt="the network visible merkle-champ" src="/img/champ.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#usernames" id="usernames"><h1>Usernames</h1></a>
<p>The public keys and usernames are stored in a global append only data structure, with names taken on a first come first served basis. This needs consensus to ensure uniqueness of usernames. This is also where the ipfs node id of the server(s) responsible for synchronising the user's writes is stored. The public key infrastructure (pki) server is called the Corenode, and its interface is the following.</p>
<pre><code class="language-java">/**
 *
 * @param username
 * @return the key chain proving the claim of the requested username and the ipfs node id of their storage
 */
CompletableFuture&lt;List&lt;UserPublicKeyLink&gt;&gt; getChain(String username);

/** Claim a username, or change the public key owning a username
 *
 * @param username
 * @param chain The changed links of the chain
 * @return True if successfully updated
 */
CompletableFuture&lt;Boolean&gt; updateChain(String username, List&lt;UserPublicKeyLink&gt; chain);

/**
 *
 * @param key the hash of the public identity key of a user
 * @return the username claimed by a given public key
 */
CompletableFuture&lt;String&gt; getUsername(PublicKeyHash key);

/**
 *
 * @param prefix
 * @return All usernames starting with prefix
 */
CompletableFuture&lt;List&lt;String&gt;&gt; getUsernames(String prefix);
</code></pre>
<a class="header" href="#follow-requests" id="follow-requests"><h1>Follow requests</h1></a>
<p>A user's storage server stores their pending follow requests until they are retrieved and deleted. These are not actually stored in ipfs itself, and reading them is guarded by a challenge protocol to mitigate against someone logging them alll now and decrypting them with a large quantum computer when one is built.</p>
<p>Follow requests contain no unencrypted data visible to the network, or server, apart from the target user. Only the target user can decrypt the follow request to see the sender.</p>
<p>The interface for sending, receiving and removing follow requests is called SocialNetwork and has the following methods:</p>
<pre><code class="language-java">/** Send a follow request to the target public key
 *
 * @param target The public identity key hash of the target user
 * @param encryptedPermission The encrypted follow request
 * @return True if successful
 */
CompletableFuture&lt;Boolean&gt; sendFollowRequest(PublicKeyHash target, byte[] encryptedPermission);

/**
 *
 * @param owner The public identity key hash of user who's pending follow requests are being retrieved
 * @param signedTime The current time signed by the owner
 * @return all the pending follow requests for the given user
 */
CompletableFuture&lt;byte[]&gt; getFollowRequests(PublicKeyHash owner, byte[] signedTime);

/** Delete a follow request for a given public key
 *
 * @param owner The public identity key hash of user who's follow request is being deleted
 * @param data The original follow request data to delete, signed by the owner
 * @return True if successful
 */
CompletableFuture&lt;Boolean&gt; removeFollowRequest(PublicKeyHash owner, byte[] data);
</code></pre>
<a class="header" href="#security" id="security"><h1>Security</h1></a>
<p>Peergos' primary focus is security.</p>
<a class="header" href="#trust-free-levels" id="trust-free-levels"><h1>Trust free levels</h1></a>
<p>Peergos is designed at every level to minimise or remove entirely any need for trust.</p>
<p>The first trust barrier is between Peergos and IPFS. A Peergos server verifies the hash of everything written to or read from IPFS. This removes the possibility of tampering at the ipfs level.</p>
<p>The second trust free barrier is between a Peergos client and a Peergos server. A Peergos client verifies the hash of every block read from or written to a Peergos server. Peergos clients also verify the signature of every signed piece of data received from Peergos. This means that once you have obtained a trustworthy copy of a Peergos client you do not need to trust a server to interact with it. </p>
<a class="header" href="#threat-models" id="threat-models"><h1>Threat models</h1></a>
<p>Peergos supports several threat models depending on the user and their situation.</p>
<a class="header" href="#casual-user" id="casual-user"><h2>Casual user:</h2></a>
<ul>
<li>Trusts the SSL certificate hierarchy and the domain name system</li>
<li>Is happy to run Javascript in their browser</li>
<li>Trusts TLS and their browser (and OS and CPU ;-) )</li>
</ul>
<p>Such a user can interact with peergos purely through a public web server that they trust over TLS.</p>
<a class="header" href="#slightly-paranoid-user" id="slightly-paranoid-user"><h2>Slightly paranoid user:</h2></a>
<ul>
<li>Doesn't trust DNS or SSL certificates</li>
<li>Is happy to run Javascript served from localhost in their browser</li>
</ul>
<p>This class of user can download and run the Peergos application and access the web interface through their browser over localhost.</p>
<a class="header" href="#more-paranoid-user" id="more-paranoid-user"><h2>More paranoid user:</h2></a>
<ul>
<li>Doesn't not trust the SSL certificate system</li>
<li>Doesn't trust DNS</li>
<li>Doesn't trust javascript</li>
</ul>
<p>This class of user can download the Peergos application (or otherwise obtain a signed copy), or build it from source. They can then run Peergos locally and use the native user interface, either the comand line or a FUSE mount. Once they have obtained or built a copy they trust, then they need trust only the integrity of TweetNacl cryptography (or our post-quantum upgrade) and the Tor architecture.  </p>
<a class="header" href="#login" id="login"><h1>Login</h1></a>
<p>Decentralised login is achieved using a capability based system. Your identity key pairs and root encryption key are derived from your password salted with your username and passed through the <a href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> hashing function (with parameters 17, 8, 1, 96). By virtue of being decentralised, we cannot rate limit attempts to crack your password, so choosing a good passord is imperative. We recommend at least 14 random alphanumeric characters.</p>
<p><img alt="Login key derivation" src="/img/scrypt.svg" class="center" style="width: 70%;" /></p>
<a class="header" href="#encryption" id="encryption"><h1>Encryption</h1></a>
<p>All your files are encrypted symmetrically with a random 256-bit key using salsa20+poly1305 (from TweetNaCl). These keys are not derived from the contents of the file (as some services do) because this leaks to the network which files you are storing. Files are split into chunks of up to 5 MiB and each chunk is independently encrypted, and optionally erasure coded. The link from one chunk of a file to the next is also encrypted so that the network cannot deduce how big an individual file is from the data at rest. </p>
<a class="header" href="#access-control" id="access-control"><h1>Access control</h1></a>
<p>Read access to your files is controlled by a data structure called cryptree, which is essentially a tree of symmetric keys, where the holder of one key can decrypt all the descendant keys. The result is extremely fine grained access control. You can grant access to someone to a file and that user won't be able to see any of the sibling files in the same folder (or even their names - or even their labels in the champ). Granting read access to a folder implies granting read access to all the contents of the folder recursively.</p>
<p><img alt="Read access capability tree" src="/img/read-cryptree.svg" class="center" style="width: 100%;" /></p>
<p>Write access is independently controlled by a similar, but simpler cryptree. All updates to a given subtree are signed by a corresponding writing key pair. When you grant write access to a file or folder then that item is moved to a new writing key pair, to keep the fine grained access control applicable to write access too. This operates independently of the read access control cryptree.</p>
<p><img alt="Write access capability tree" src="/img/write-cryptree.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#metadata" id="metadata"><h1>Metadata</h1></a>
<p>All of the metadata for a given file is encrypted, with a different symmetric key from the file itself. This includes the name for directories and also the filesize, modification time, any thumbnail and mime type for files. The size of files is further hidden by splitting files into 5MiB chunks and storing each chunk under a random label (along with those for all other files owned by the same user and controlled by the same writing key pair).</p>
<p>The metadata around access patterns will be hidden by hosting files behind a tor hidden service once Tor is integrated. This will ensure that when one user reads a file shared with them by a friend this access does not leak to the network the fact that they are friends. </p>
<a class="header" href="#quantum-resistance" id="quantum-resistance"><h1>Quantum resistance</h1></a>
<p>Peergos aims to be a long term secure file storage system, and hence we have architected it with an awareness of quantum computer based attacks (many of us are ex physicists).</p>
<p>Files that you store but don't share with anyone are already resistant to quantum computer based attacks. This is because the process from logging in to decrypting them only involves hashing and symmetric encryption, neither of which are significantly weakened by a quantum computer.</p>
<p>Files that have been shared are currently vulnerable to a quantum computer attack because they use asymmetric elliptic curve cryptography (Curve25519) to share the decryption capability. However, we plan to upgade to a suitable post-quantum algorithm soon. </p>
<a class="header" href="#social-graph" id="social-graph"><h1>Social graph</h1></a>
<p>Following a user is implemented by them sharing read access to a directory in their filesystem. The read capability is sent encrypted from a random single use keypair to the target user's public key. These requests will be sent over Tor to that user's hidden service to hide the metadata from the network. Once retrieved, the receiving user stores the capability in their own storage, symmetrically encrypted and deletes the follow request from their server. </p>
<a class="header" href="#public-key-infrastructure" id="public-key-infrastructure"><h1>Public Key Infrastructure</h1></a>
<p>All users have a public identity key, and these are stored in a merkle-champ. This structure is mirrored by all nodes (and will eventually be sharded). This includes the user's claim to a username along with an expiry, and their current storage server. The effect is similar to certificate transparency logs.</p>
<p>This allows users to do public key lookups without leaking to the network who they are looking up. Users also store the keys of their friends in their own filesystem in a TOFU setup. This means that ordinary usage doesn't involve looking up keys from the public blockchain. </p>
<a class="header" href="#how-does-it-work" id="how-does-it-work"><h1>How does it work?</h1></a>
<p>This section goes into technical detail about how different operations work in Peerogs. </p>
<a class="header" href="#signing-up" id="signing-up"><h1>Signing up</h1></a>
<p>The steps involved in signing up are:</p>
<ol>
<li>
<p>Register the username</p>
<ul>
<li>Hash the password and username through scrypt to get the identity key pair, following key pair and symmetric root key.</li>
<li>Generate a signed username claim including an expiry, and the ipfs node id of the storage server (the server we are signing up through) This is just identity.sign(username, expiry, [storage id])</li>
<li>Send this claim to the pki node for confirmation</li>
</ul>
</li>
<li>
<p>Set up your identity</p>
<ul>
<li>Write the public identity key to ipfs</li>
<li>Write the public following key to ipfs</li>
<li>Create a <a href="/architecture/writer.html">WriterData</a> for the identity key pair with the two resulting public key hashes</li>
<li>Generate a random key pair to control writes to the users filesystem. Add this key pair as an owned key to the identity WriterData.</li>
<li>Commit the identity WriterData (write it to ipfs and set the mutable pointer for the identity key pair to the resulting hash).</li>
</ul>
</li>
<li>
<p>Set up your filesystem</p>
<ul>
<li>Create a DirAccess <a href="/security/cryptree.html">cryptree</a> node for the user's root directory, and add this to the champ of the filesystem key pair.</li>
<li>Add a write capability (encrypted) to the static data section of the identity key pair's WriterData</li>
<li>Create the /username/shared directory which is used when sending follow requests</li>
</ul>
</li>
</ol>
<a class="header" href="#uploading-a-file" id="uploading-a-file"><h1>Uploading a file</h1></a>
<p>A file upload proceeds in the following steps</p>
<ol>
<li>
<p>Check filename is valid and free</p>
</li>
<li>
<p>Create a transaction file with a plan for the upload</p>
</li>
<li>
<p>For every section of the file which is up to 5 MiB:</p>
<ul>
<li>Encrypt the 5 MiB file section with a random symmetric key</li>
<li>Split the cipher text into 128 KiB fragments</li>
<li>Create a FileAccess cryptree node with merkle links to all the resulting fragments and an encrypted link to the next section (even if there isn't a next section)</li>
<li>Add the FileAccess to the champ of the writing key pair under a random 32 byte label</li>
</ul>
</li>
<li>
<p>Add a cryptree link from the parent directory to the file</p>
</li>
<li>
<p>Delete the transaction file</p>
</li>
</ol>
<p>A modification, such as uploading a file, can be done through any Peergos server as the writes are <a href="/dev/proxy.html">proxied</a> through an ipfs p2p stream to the owner's storage ipfs node.</p>
<a class="header" href="#sending-a-follow-request" id="sending-a-follow-request"><h1>Sending a follow request</h1></a>
<p>Sending a follow request proceeds in the following steps:</p>
<ol>
<li>
<p>Look up the target friend's public following key</p>
</li>
<li>
<p>Create a directory /our-name/shared/friend-name</p>
</li>
<li>
<p>Encrypt a read capability for that directory using a random key pair to the target's following key. Using a random keypair ensures that noone but the target friend can see who sent the request.</p>
</li>
<li>
<p>Send the follow request to the storage server of the target friend</p>
</li>
</ol>
<p>The target can then either allow and reciprocate (full bi-directional friendship), allow (you are following them), reciprocate (they are following you) or deny. If they have reciprocated then you can grant read or write access to any file or folder by adding a read or write capability in their directory in your space.</p>
<p>When you receive a follow request and either allow or reciprocate it then you add the capability in the request to your static data on your identity WriterData, so you can find it again later, before deleting the follow request from your server. </p>
<a class="header" href="#proxying-requests" id="proxying-requests"><h1>Proxying requests</h1></a>
<p>Any modifying request needs to be proxied to the correct destination server. This could be signing up, uploading a file, or sending a follow request. This is achieved using an ipfs p2p stream. In particular, because all these requests are http requests, we use the http p2p proxy exposed locally on the ipfs gateway. It means we can send any request to</p>
<p>http://localhost:8080/p2p/$target_node_id/http/$path</p>
<p>and it will go through an end to end encrypted stream through the ipfs network to the destination node, which then sends it to the local Peergos server at:</p>
<p>http://localhost:8000/$path</p>
<p>This is illustrated below:
<img alt="Proxying a request through ipfs" src="/img/proxy.svg" class="center" style="width: 100%;" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
