<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="overview/overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><a href="features/features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li><ol class="section"><li><a href="features/self.html"><strong aria-hidden="true">2.1.</strong> Self hosting</a></li><li><a href="features/p2p.html"><strong aria-hidden="true">2.2.</strong> Peer-to-peer</a></li><li><a href="features/trust.html"><strong aria-hidden="true">2.3.</strong> Trust free server</a></li><li><a href="features/multi.html"><strong aria-hidden="true">2.4.</strong> Multi-device login</a></li><li><a href="features/web.html"><strong aria-hidden="true">2.5.</strong> Web interface</a></li><li><a href="features/social.html"><strong aria-hidden="true">2.6.</strong> Social</a></li><li><a href="features/sharing.html"><strong aria-hidden="true">2.7.</strong> Sharing</a></li><li><a href="features/large.html"><strong aria-hidden="true">2.8.</strong> Large files</a></li><li><a href="features/streaming.html"><strong aria-hidden="true">2.9.</strong> Streaming</a></li><li><a href="features/viewers.html"><strong aria-hidden="true">2.10.</strong> File viewers</a></li><li><a href="features/secret.html"><strong aria-hidden="true">2.11.</strong> Secret links</a></li><li><a href="features/migration.html"><strong aria-hidden="true">2.12.</strong> Migration</a></li><li><a href="features/sync.html"><strong aria-hidden="true">2.13.</strong> File Sync</a></li><li><a href="features/open.html"><strong aria-hidden="true">2.14.</strong> Open source</a></li><li><a href="features/apps.html"><strong aria-hidden="true">2.15.</strong> Custom Apps</a></li><li><a href="features/private-web.html"><strong aria-hidden="true">2.16.</strong> Private websites</a></li></ol></li><li><a href="architecture/architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li><ol class="section"><li><a href="architecture/logical.html"><strong aria-hidden="true">3.1.</strong> Logical</a></li><li><a href="architecture/physical.html"><strong aria-hidden="true">3.2.</strong> Physical</a></li><li><a href="architecture/immutable.html"><strong aria-hidden="true">3.3.</strong> Immutable data</a></li><li><a href="architecture/mutable.html"><strong aria-hidden="true">3.4.</strong> Mutable pointers</a></li><li><a href="architecture/writer.html"><strong aria-hidden="true">3.5.</strong> Writing subspaces</a></li><li><a href="architecture/champ.html"><strong aria-hidden="true">3.6.</strong> Merkle-CHAMP</a></li><li><a href="architecture/pki.html"><strong aria-hidden="true">3.7.</strong> Usernames</a></li><li><a href="architecture/follow.html"><strong aria-hidden="true">3.8.</strong> Follow requests</a></li></ol></li><li><a href="security/security.html"><strong aria-hidden="true">4.</strong> Security</a></li><li><ol class="section"><li><a href="security/trust.html"><strong aria-hidden="true">4.1.</strong> Trust free layers</a></li><li><a href="security/threats.html"><strong aria-hidden="true">4.2.</strong> Threat models</a></li><li><a href="security/login.html"><strong aria-hidden="true">4.3.</strong> Login</a></li><li><a href="security/encryption.html"><strong aria-hidden="true">4.4.</strong> Encryption</a></li><li><a href="security/bats.html"><strong aria-hidden="true">4.5.</strong> Block access control</a></li><li><a href="security/cryptree.html"><strong aria-hidden="true">4.6.</strong> File access control</a></li><li><a href="security/meta.html"><strong aria-hidden="true">4.7.</strong> Metadata</a></li><li><a href="security/quantum.html"><strong aria-hidden="true">4.8.</strong> Quantum resistance</a></li><li><a href="security/social.html"><strong aria-hidden="true">4.9.</strong> Social graph</a></li><li><a href="security/pki.html"><strong aria-hidden="true">4.10.</strong> PKI</a></li></ol></li><li><a href="dev/details.html"><strong aria-hidden="true">5.</strong> How does it work?</a></li><li><ol class="section"><li><a href="dev/signup.html"><strong aria-hidden="true">5.1.</strong> Signing up</a></li><li><a href="dev/upload.html"><strong aria-hidden="true">5.2.</strong> Uploading a file</a></li><li><a href="dev/follow.html"><strong aria-hidden="true">5.3.</strong> Sending a follow request</a></li><li><a href="dev/proxy.html"><strong aria-hidden="true">5.4.</strong> Proxying requests</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#peergos---your-private-online-space" id="peergos---your-private-online-space"><h1>Peergos - your private online space</h1></a>
<p>Peergos is building the next web - the private web, where end users are in control. Imagine web apps being secure by default and unable to track you. Imagine being able to control exactly what personal data each web app can see. Imagine never having to log in to an app ever again. You own your data and decide where it is stored and who can see it. At Peergos, we believe that privacy is a fundamental human right and we want to make it easy for everyone to interact online in ways that respect this right.</p>
<p>The foundation of Peergos is a peer-to-peer encrypted global filesystem with fine-grained access control designed to be resistant to surveillance of data content or friendship graphs. It will have a secure messenger, with optional interoperability with email, and a totally private and secure social network, where users are in control of who sees what (executed cryptographically). Our motto at Peergos is, <strong>&quot;Control your data, control your destiny.&quot;</strong></p>
<p>The name Peergos comes from the Greek word Πύργος (Pyrgos), which means stronghold or tower, but phonetically spelt with the nice connection to being peer-to-peer. It is pronounced peer-goss, as in gossip.</p>
<p><strong>WARNING:</strong> Peergos has had an audit by Cure53, but is still in active development. Some of the features in this documentation are yet to be implemented, in particular, onion routing is not used yet.</p>
<a class="header" href="#aims" id="aims"><h2>Aims</h2></a>
<ul>
<li><strong>Securely</strong> and <strong>privately</strong> store files in a peer to peer network which has no central node and is generally difficult to disrupt or surveil</li>
<li><strong>Secure sharing</strong> of such files with other users of the network without visible meta-data (who shares with who)</li>
<li><strong>Trust free</strong> servers and storage. Clients do not need to trust their server or storage. Data, metadata, and contact lists are never exposed to your server.</li>
<li><strong>Beautiful user interface</strong> that any computer or mobile user can understand</li>
<li><strong>Secure messaging</strong>, with optional interop with actual email</li>
<li><strong>Independent</strong> of the central SSL CA trust architecture, and the domain name system</li>
<li><strong>Self hostable</strong> - A user should be able to easily run Peergos on a machine in their home and get their own Peergos storage space, and social communication platform from it</li>
<li>Allow users to run web apps within Peergos (and served directly from Peergos) which are totally sandboxed and unable to track users or exfiltrate data</li>
<li>Secure <em>web interface</em> as well as desktop clients, native folder sync, and a command line interface</li>
<li>Do not rely on any cryptocurrency</li>
<li>Enable users to <em>collaborate</em>, editing a document in place concurrently</li>
<li>Secure real time chat, and <em>video conferencing</em> able to handle 100s of participants, fully end-to-end encrypted</li>
<li>Social <em>account recovery</em> - designate N of M friends who can collaborate to recover your account if you lose your password</li>
<li>Optional use of U2F for securing login</li>
</ul>
<a class="header" href="#features" id="features"><h1>Features</h1></a>
<ul>
<li>Self hosting</li>
<li>Peer-to-peer</li>
<li>Multi-device login</li>
<li>Web interface</li>
<li>Social</li>
<li>Sharing</li>
<li>Large files</li>
<li>Streaming</li>
<li>File viewers</li>
<li>Secret links</li>
<li>Migration</li>
<li>Folder Sync</li>
<li>Open source</li>
<li>Custom Apps</li>
<li>Private Websites</li>
</ul>
<a class="header" href="#self-hosting" id="self-hosting"><h1>Self hosting</h1></a>
<p>Peergos is fully self hostable. You can run peergos from your own home or server to obtain as much storage and bandwidth as you need, whilst still transparently interacting with anyone using any other server. Because the server only ever sees encrypted data you can also tell it to directly store your data in a standard cloud storage provider like Backblaze or Amazon without any loss of privacy.</p>
<p><img alt="Self host at home or on your own server" src="/img/self-host.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#peer-to-peer" id="peer-to-peer"><h1>Peer-to-peer</h1></a>
<p>Peergos is built with a peer-to-peer architecture to protect against censorship and surveillance and to improve resiliency. There is no central surveillance point that an attacker could monitor all file transfers through. There is also no central dns name or TLS certificate authority that could be used to attack the network.</p>
<p><img alt="Peergos has a peer-to-peer architecture" src="/img/p2p.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#trust-free-servers" id="trust-free-servers"><h1>Trust free servers</h1></a>
<p>Peergos is designed so that clients do no need to trust the Peergos server they are talking to. Hashes and signatures are all verified client side for reads and writes. Data can also be mirrored to transparently provide redundancy. </p>
<a class="header" href="#multi-device-login" id="multi-device-login"><h1>Multi-device login</h1></a>
<p>Peergos is naturally mutli-device. You can log in to your account from any device, and through any Peergos server. It is not tied to any other data like your phone number or email address. All you need is your username and your password. Any modern browser will suffice, including mobile.</p>
<p><img alt="Login through any device with a web browser" src="/img/multi-device.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#web-interface" id="web-interface"><h1>Web interface</h1></a>
<p>In keeping with our aim to be as convenient to use as existing centralised services, Peergos has a web interface which can be used instead of a native application. This interface does not require any special knowledge, especially not of cryptography or keys, but should none-the-less encourage/enforce safe practices. The web interface does not load any code from third-party servers and is entirely self hosted. You even load it directly from ipfs and log in!</p>
<p>The web interface can be accessed from a public server over https or from your machine if you run Peergos locally. </p>
<a class="header" href="#social" id="social"><h1>Social</h1></a>
<p>Peergos users can send follow requests to each other. If accepted, the other user can then share files or send messages with you. Following is a one-way mechanism: If Agata follows Bartek then Bartek can share files with Agata. If Bartek is also following Agata, then she can also share files with Bartek. Following can be revoked by either user at any point.</p>
<p>Your friend list is kept encrypted in your own Peergos space, hidden from other users and the server.</p>
<p>There is also a secret link mechanism for sharing files with people who do not have peergos accounts. </p>
<a class="header" href="#sharing" id="sharing"><h1>Sharing</h1></a>
<p>A file or folder can be shared with any user who is following you. This access can be read only or writable. Access can be revoked at any time whilst maintaining access to anyone else the item is shared with. This is all achieved cryptographically with capabilities and lazy re-encryption. </p>
<a class="header" href="#large-files" id="large-files"><h1>Large files</h1></a>
<p>There is no file size limit in Peergos apart from what will fit in your storage quota. Despite doing client side encryption/decryption we can still upload or download arbitrarily large files sending directly from/to the filesystem. </p>
<a class="header" href="#streaming" id="streaming"><h1>Streaming</h1></a>
<p>Peergos is naturally streaming and despite having to decrypt files in the client we can still stream large files directly with low ram usage. This allows us to stream large videos in the browser directly to a html5 video element. </p>
<a class="header" href="#file-viewers" id="file-viewers"><h1>File viewers</h1></a>
<p>There are several built-in file viewers in Peergos. We have viewers for the following file types:</p>
<ul>
<li>images</li>
<li>videos</li>
<li>audio</li>
<li>pdf</li>
<li>binary (hex viewer)</li>
</ul>
<p>We have editors for the following formats</p>
<ul>
<li>text</li>
<li>markdown</li>
<li>code</li>
</ul>
<p>We support the following languages in the code editor:</p>
<ul>
<li>c</li>
<li>c++</li>
<li>Clojure</li>
<li>css</li>
<li>diff</li>
<li>Go</li>
<li>html</li>
<li>Java</li>
<li>Javascript</li>
<li>Kotlin</li>
<li>python</li>
<li>Ruby</li>
<li>Rust</li>
<li>Scala</li>
<li>shell</li>
<li>tex</li>
<li>xml</li>
<li>yaml</li>
</ul>
<a class="header" href="#secret-links" id="secret-links"><h1>Secret links</h1></a>
<p>A secret link can be generated to point to any file or folder. Anyone with a (Javascript enabled) web browser can view such a link. This is a capability based link which includes the necessary key in the hash fragment of the url. A secret link doesn't expose the file to the network, or indeed to anyone who doesn't have the link itself because the key material isn't sent to the server.</p>
<p>An example of a secret link to a folder is:</p>
<p><a href="https://demo.peergos.net/#6MDZhRRPT4ugkJuUfcPPhf1US9u7FvRALmj42mJ6e3yDibnLtqfhchE6Frm6Lf/6MDZhRRPT4ugkJuUfcZdxu6JLKyrLBE36Kasxb4jix7An4dbeiekpDF6h2fDBM/HUja6zmXVs24zcRf15s1MWB7kfvyTCp2X9NF4EZqcw7/5Pf7SvCKyBYfP1vm5LfTSw8TMHtLWvJDLv1P4QtCXV8P2Zv8FwR">https://demo.peergos.net/#6MDZhRRPT4ugkJuUfcPPhf1US9u7FvRALmj42mJ6e3yDibnLtqfhchE6Frm6Lf/6MDZhRRPT4ugkJuUfcZdxu6JLKyrLBE36Kasxb4jix7An4dbeiekpDF6h2fDBM/HUja6zmXVs24zcRf15s1MWB7kfvyTCp2X9NF4EZqcw7/5Pf7SvCKyBYfP1vm5LfTSw8TMHtLWvJDLv1P4QtCXV8P2Zv8FwR</a></p>
<a class="header" href="#migration" id="migration"><h1>Migration</h1></a>
<p>Your identity in Peergos is not tied to any particular server. Compared to other federated social networks where moving server typically involves losing your social network and meta-data, if not data too, Peergos allows you to transparently migrate between servers and storage providers without any action required from your friends and without any data loss.</p>
<p>This means, for example, you could start out by creating an account on our demo server which gives you a small amount of storage, then effortlessly migrate to a paid server, or to your own server when you realise how awesome Peergos is. </p>
<a class="header" href="#file-sync" id="file-sync"><h1>File Sync</h1></a>
<p>Peergos has the ability to do standard directory syncing and transparently mount a folder to your host operating system. This is achieved with a FUSE binding (or equivalent for Windows and MacOS). </p>
<a class="header" href="#open-source" id="open-source"><h1>Open source</h1></a>
<p>Peergos is fully open-source, both clients, and server (incuding the web-interface). The main interface is a web-ui, but Peergos can also be accessed using a Java client on the command line, or with a FUSE mount of your Peergos filesystem.</p>
<p>No part of our infrastructure, apart from TLS and Peergos private keys, are secret. We also have reproducible builds (we don't use npm or browserify etc.) We also vendor all dependencies so any historic git commit should be buildable without any external data.</p>
<p>Eventually we want to self host our git repos in Peergos itself. </p>
<a class="header" href="#custom-apps" id="custom-apps"><h1>Custom Apps</h1></a>
<p>Peergos Apps are a way to extend the Peergos platform to add custom functionality</p>
<p>When an app is run, its HTML5 assets are rendered in a unique hostname (sha256(app path).$peergos-domain) of the peergos server, e.g. https://bciqjmdntozhuanb2c3ka5vtqpux75j5symbyomhkpnilndngl6iaspy.peergos.net. The app domain is isolated from the main peergos domain in a separate OS process, and from other apps. The app domain is also locked down with CSP http headers so it cannot make any external requests which could be used to exfilrate data [0]. Requests made by the app are intercepted in a service worker and translated to post messages which are sent to the main peergos tab. That is where the requests are checked for validity and permissions are enforced. By default, an app has no permissions and can only read its own assets. Running an app also doesn't reveal its assets to the server - they are served via a service worker and post messages to the main peergos tab, and thus benefit from all the existing privacy protections in Peergos.</p>
<p>[0] This is currently not true until browsers implement the <a href="https://caniuse.com/mdn-http_headers_csp_content-security-policy_prefetch-src">prefetch-src</a> CSP directive to allow blocking DNS prefetch, and implement <a href="https://github.com/w3c/webappsec-csp/issues/92">webrtc CSP</a> which blocks any webrtc connections. So only install apps from authors you trust for now, unless they don't require any permissions which is safe.</p>
<a class="header" href="#use-cases" id="use-cases"><h2>Use cases:</h2></a>
<ol>
<li>
<p>Media Player App. The App should appear as a context menu item when a media file is selected on the Drive screen.</p>
</li>
<li>
<p>Word Processor App. As well as having read access to a document file, the App should be able to overwrite the contents of the document file.</p>
</li>
<li>
<p>Image Gallery App. The App should be able to read image files from the selected Folder tree.</p>
</li>
<li>
<p>White Board App. App will appear on the Launcher page. App can create, retrieve, update, append and delete files within it’s own App space.</p>
</li>
</ol>
<a class="header" href="#example-apps" id="example-apps"><h2>Example apps</h2></a>
<p>You can find some example apps here: <a href="https://github.com/Peergos/example-apps">https://github.com/Peergos/example-apps</a></p>
<a class="header" href="#anatomy-of-a-peergos-app" id="anatomy-of-a-peergos-app"><h2>Anatomy of a Peergos App</h2></a>
<p>An app consists of plain HTML/Javascript/CSS packaged in a folder</p>
<p>The App is described by a mandatory manifest file called peergos-app.json</p>
<a class="header" href="#app-folder-structure" id="app-folder-structure"><h3>App Folder Structure</h3></a>
<p>asssets                 - Must contain index.html as an entry point</p>
<p>data                    - Files under the control of the App</p>
<p>peergos-app.json        - manifest file</p>
<a class="header" href="#peergos-appjson" id="peergos-appjson"><h3>Peergos-app.json</h3></a>
<p>This file describes the App. It also indicates the permissions required for the App to function</p>
<p>Fields:</p>
<p>schemaVersion   - Currently always set to 1</p>
<p>displayName     - Used for display.  Limited to 25 characters. (alphanumeric plus dash and underscore).</p>
<p>version         - Format of Major.Minor.Patch-Suffix. Example: 0.0.1-initial</p>
<p>description     - Text. Length must not exceed 100 characters</p>
<p>author          - Text. Length must not exceed 32 characters</p>
<p>fileExtensions  - Array of target file extensions e.g. [&quot;jpg&quot;,&quot;png&quot;,&quot;gif&quot;]</p>
<p>mimeTypes       - Array of target mime types e.g. [&quot;application/zip&quot;,&quot;application/vnd.peergos-todo&quot;,&quot;video/quicktime&quot;]</p>
<p>fileTypes       - Another way to target files e.g. [“image”, “video”, “audio”, “text”]</p>
<p>launchable      - Indicates App can be opened on the Launcher page</p>
<p>folderAction    - Indicates App acts on folders</p>
<p>appIcon         - filename of image to use as icon on launcher page. Must be available in assets folder</p>
<p>permissions     - see below</p>
<p>Permissions:</p>
<p>STORE_APP_DATA  - Can store and read files in a folder private to the app</p>
<p>EDIT_CHOSEN_FILE – Can modify file chosen by user</p>
<p>READ_CHOSEN_FOLDER – Can read contents of folder chosen by user</p>
<p>These are already quite powerful, but we plan to add more permissions as we see more use cases.</p>
<a class="header" href="#peergos-rest-api" id="peergos-rest-api"><h2>Peergos REST API</h2></a>
<p>The following endpoints are available:</p>
<p>/peergos-api/v0/data/path.to.file – The data folder is where the App can store and retrieve files</p>
<p>/peergos-api/v0/form/path.to.file – An app can POST a HTML Form and have the results stored in a file of the same name in the data folder.</p>
<p>If an App is launched from a file/folder context menu item, the path of the file/folder will be available via:</p>
<pre><code class="language-js">let url = new URL(window.location.href);
let filePath = url.searchParams.get(&quot;path&quot;);
</code></pre>
<p>Dark mode can be detected via the theme param</p>
<pre><code class="language-js">let theme = url.searchParams.get(&quot;theme&quot;);// curent values: ['dark-mode', '']
</code></pre>
<a class="header" href="#the-following-http-actions-are-supported" id="the-following-http-actions-are-supported"><h3>The following HTTP actions are supported:</h3></a>
<p>GET – Retrieve a resource. Can be a file or folder</p>
<p>Response code: 200 – success.</p>
<p>404, 400 – request failed</p>
<p>Notes:</p>
<ol>
<li>
<p>If resource is a folder the response will look like: {files:[“file1.txt”, “file2.txt”], subFolders:[“folder”]}</p>
</li>
<li>
<p>If the file is a media file with a thumbnail, provide ?preview=true to the request to have the thumbnail returned in the Response as a Base64 string.</p>
</li>
</ol>
<p>POST – Create a resource</p>
<p>Response code: 201 – create success. See Response header field: location</p>
<p>200 for POST using form/</p>
<p>400 – request failed</p>
<p>PUT – update a resource</p>
<p>Response code: 201 – create success. See Response header field: location</p>
<p>200 – for update success</p>
<p>400 – request failed</p>
<p>DELETE – delete a file</p>
<p>204 – delete success</p>
<p>400 – request failed</p>
<p>PATCH – append to a file only supported</p>
<p>204 – Append success. See Response header field: Content-Location</p>
<p>400 – request failed</p>
<a class="header" href="#developing-a-peergos-app" id="developing-a-peergos-app"><h2>Developing a Peergos App</h2></a>
<p>Select the peergos-app.json file and choose ‘Run App’ to launch the app from the current directory.</p>
<p>The install process will detect if an existing App has the same name.
It will display the version of the already installed App.</p>
<p>During install the App's files are copied to an internal folder. Any existing contents in the assets folder will be replaced.
The contents of the data folder will be added to.<br />
The previously installed peergos-app.json file is copied to the App’s data directory as ‘peergos-app-previous.json’.</p>
<a class="header" href="#private-websites" id="private-websites"><h1>Private Websites</h1></a>
<p>You can turn any folder in Peergos into a private website, benefitting from the built-in access control and privacy. Such websites can be viewed using a built-in browser <a href="./apps.html">app</a>. This browser isolates websites from different owners using different sub domains just as different apps are themselves isolated. Such websites are locked down such that external communication is impossible [0]. This means that 3rd party tracking is impossible. The beautiful thing here is that 1st party tracking is also not easy (and can be made impossible) because the paths are resolved locally in the browser and all requests go through the peergos server you are connecting to. This means browser fingerprinting is irrelevant for such websites because no information can be exfiltrated!</p>
<p>You can share websites privately with friends on peergos the same way you share any file or folder. You can even share them with anyone via a secret link!</p>
<p>A private website can also link to any other websites in Peergos, including those owned by others, by the human readable path in the Peergos global filesystem. Following such a link will only work if you also have read access to the destination.</p>
<p>The possibilities are huge here for a better, more private web that protects people from surveillance. You can also edit your website's directly in Peergos. It has never been easier to host your own website securely!</p>
<p>[0] This is currently not true until browsers implement the <a href="https://caniuse.com/mdn-http_headers_csp_content-security-policy_prefetch-src">prefetch-src</a> CSP directive to allow blocking DNS prefetch, and implement <a href="https://github.com/w3c/webappsec-csp/issues/92">webrtc CSP</a> which blocks any webrtc connections. </p>
<a class="header" href="#peergos-architecture" id="peergos-architecture"><h1>Peergos architecture</h1></a>
<a class="header" href="#logical" id="logical"><h1>Logical</h1></a>
<p>The logical architecture of Peergos consists of the following:</p>
<ol>
<li>Content addressed storage: a data store with a mapping from the hash of a block of data to the data itself</li>
<li>Mutable pointers: a mapping from a public key to a hash</li>
<li>PKI: a global append only log for the username &lt;==&gt; {identity public key, storage public key} mappings</li>
<li>Social: each user designates a server for sending follow requests for users to (the server can't see the source user). This is the same as the storage server for that user and is identified and contacted via its public key.</li>
</ol>
<p><img alt="Logical Architecture" src="/img/logical-arch.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#physical" id="physical"><h1>Physical</h1></a>
<p>Each user must have at least one Peergos server (which includes an instance of IPFS). This server stores their data, their mutable pointers and any pending follow requests for them. There is also the global append only log for the PKI which is mirrored on every node. Communication between IPFS instances is done over encrypted TLS 1.3 streams.</p>
<p><img alt="The physical architecture" src="/img/physical-arch.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#immutable-data" id="immutable-data"><h1>Immutable data</h1></a>
<p>The immutable data store is provided by IPFS and allows anyone authorised to retrieve cipher text from its hash through any Peergos node. Note that IPFS is used in a fully trustless manner. Every hash and signature is checked client side during reads and writes. The underlying storage can be provided by the local harddisk or any S3 compatible object storage without loss of privacy. Access to raw blocks is controlled using S3 V4 signatures from an allowed <a href="/security/bats.html">Block Access Token</a> (BAT). Each block specifies which BATs are allowed to retrieve it. Any node that retrieves such a block enforces the same auth on it.</p>
<p>The interface for this storage is ContentAddressedStorage, with the following methods:</p>
<pre><code class="language-java">
     /**
     *
     * @return The identity (hash of the public key) of the storage node we are talking to
     */
    CompletableFuture&lt;Cid&gt; id();

    /**
     *
     * @param owner
     * @return A new transaction id that can be used to group writes together and protect them from being garbage
     * collected before they have been pinned.
     */
    CompletableFuture&lt;TransactionId&gt; startTransaction(PublicKeyHash owner);

    /**
     * Release all associated objects from this transaction to allow them to be garbage collected if they haven't been
     * pinned.
     * @param owner
     * @param tid
     * @return
     */
    CompletableFuture&lt;Boolean&gt; closeTransaction(PublicKeyHash owner, TransactionId tid);

    /**
     *
     * @param owner The owner of these blocks of data
     * @param writer The public signing key authorizing these writes, which must be owned by the owner key
     * @param signedHashes The signatures of the sha256 of each block being written (by the writer)
     * @param blocks The blocks to write
     * @param tid The transaction to group these writes under
     * @return
     */
    CompletableFuture&lt;List&lt;Cid&gt;&gt; put(PublicKeyHash owner,
                                     PublicKeyHash writer,
                                     List&lt;byte[]&gt; signedHashes,
                                     List&lt;byte[]&gt; blocks,
                                     TransactionId tid);


    /**
     *
     * @param hash
     * @return The data with the requested hash, deserialized into cbor, or Optional.empty() if no object can be found
     */
    CompletableFuture&lt;Optional&lt;CborObject&gt;&gt; get(Cid hash, Optional&lt;BatWithId&gt; bat);

    /**
     * Write a block of data that is just raw bytes, not ipld structured cbor
     * @param owner
     * @param writer
     * @param signedHashes
     * @param blocks
     * @param tid
     * @param progressCounter
     * @return
     */
    CompletableFuture&lt;List&lt;Cid&gt;&gt; putRaw(PublicKeyHash owner,
                                        PublicKeyHash writer,
                                        List&lt;byte[]&gt; signedHashes,
                                        List&lt;byte[]&gt; blocks,
                                        TransactionId tid,
                                        ProgressConsumer&lt;Long&gt; progressCounter);

    /**
     * Get a block of data that is not in ipld cbor format, just raw bytes
     * @param hash
     * @return
     */
    CompletableFuture&lt;Optional&lt;byte[]&gt;&gt; getRaw(Cid hash, Optional&lt;BatWithId&gt; bat);

    CompletableFuture&lt;List&lt;byte[]&gt;&gt; getChampLookup(PublicKeyHash owner, Cid root, byte[] champKey, Optional&lt;BatWithId&gt; bat);
</code></pre>
<a class="header" href="#mutable" id="mutable"><h1>Mutable</h1></a>
<p>Mutable pointers in Peergos are just a mapping from a public key to a root hash. Clearly, being mutable, they need some kind of synchronization or concurrent data structure. Each user lists an ipfs node id (the hash of its public key) which is responsible for synchronising their writes and publishing the latest root hashes. This means the global filesystem is sharded by username and each user can use an ipfs instance (or cluster) with sufficient capability for their bandwidth requirements.</p>
<p>Initially each user's file system is under a single public key. Additional keys are generated when granting write access.</p>
<p>The interface for MutablePointers has the following methods:</p>
<pre><code class="language-java">/** Update the hash that a public key maps to (doing a cas with the existing value)
 *
 * @param owner The owner of this signing key
 * @param writer The public signing key
 * @param writerSignedBtreeRootHash the signed serialization of the HashCasPair
 * @return True when sucessfully completed
 */
CompletableFuture&lt;Boolean&gt; setPointer(PublicKeyHash owner, PublicKeyHash writer, byte[] writerSignedBtreeRootHash);

/** Get the current hash a public key maps to
 *
 * @param writer The public signing key
 * @return The signed cas of the pointer from its previous value to its current value
 */
CompletableFuture&lt;Optional&lt;byte[]&gt;&gt; getPointer(PublicKeyHash owner, PublicKeyHash writer);
</code></pre>
<a class="header" href="#writing-subspaces" id="writing-subspaces"><h1>Writing subspaces</h1></a>
<p>Each user has a randomly generated writing key pair which controls writes to their filesystem. They can create new writing key pairs for any subtree, for example when granting write access to a file or folder. If desired, a given writing key can be quota controlled, to prevent users to which you've granted write access to a file from filling your data store.</p>
<p>Every signing keypair, including your identity keypair, and your root writing keypair, map to a data structure called WriterData. A WriterData can contain merkle links to roots of merkle champs and various public keys. The full data structure is listed below. If any of the properties are empty they do not contribute to the size of the serialized WriterData.</p>
<pre><code class="language-java">// the public signing key controlling this subspace
PublicKeyHash controller;

// publicly readable and present on owner keys
Optional&lt;SecretGenerationAlgorithm&gt; generationAlgorithm;

// This is the root of a champ containing publicly shared files and folders (a lookup from path to capability)
Optional&lt;Multihash&gt; publicData;

// The public boxing key to encrypt follow requests to
Optional&lt;PublicKeyHash&gt; followRequestReceiver;

// Any keys directly owned by the controller, that aren't named
Set&lt;PublicKeyHash&gt; ownedKeys;

// Any keys directly owned by the controller that have specific labels
Map&lt;String, PublicKeyHash&gt; namedOwnedKeys;

// Encrypted entry points to our and our friends file systems (present on owner keys)
Optional&lt;UserStaticData&gt; staticData;

// This is the root of a champ containing the controller's filesystem (present on writer keys)
Optional&lt;Multihash&gt; tree;
</code></pre>
<a class="header" href="#merkle-champ" id="merkle-champ"><h1>Merkle-CHAMP</h1></a>
<p>The main network visible data structure in Peergos is a merkle compressed hash array mapped trie, or merkle-champ. This data structure is explained in the next section. All the data under a given writing keypair has its own merkle-champ. This is just a mapping from random 32 byte labels to cipher-text blobs. These blobs are <a href="/security/cryptree.html">cryptree</a> nodes containing the cryptree data structure, and, in the case of a file section, merkle links to encrypted file fragments. A merkle-link is just a hash that references another ipfs object. Each 5 MiB section of a file is stored under a different random label in the btree, and similarly with large directories.</p>
<p><img alt="the network visible merkle-champ" src="/img/champ.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#usernames" id="usernames"><h1>Usernames</h1></a>
<p>The public keys and usernames are stored in a global append only data structure, with names taken on a first come first served basis. This needs consensus to ensure uniqueness of usernames. This is also where the ipfs node id of the server(s) responsible for synchronising the user's writes is stored. The public key infrastructure (pki) server is called the Corenode, and its interface is the following.</p>
<pre><code class="language-java">/**
 *
 * @param username
 * @return the key chain proving the claim of the requested username and the ipfs node id of their storage
 */
CompletableFuture&lt;List&lt;UserPublicKeyLink&gt;&gt; getChain(String username);

/** Claim a username, or change the public key owning a username
 *
 * @param username
 * @param chain The changed links of the chain
 * @return True if successfully updated
 */
CompletableFuture&lt;Boolean&gt; updateChain(String username, List&lt;UserPublicKeyLink&gt; chain);

/**
 *
 * @param key the hash of the public identity key of a user
 * @return the username claimed by a given public key
 */
CompletableFuture&lt;String&gt; getUsername(PublicKeyHash key);

/**
 *
 * @param prefix
 * @return All usernames starting with prefix
 */
CompletableFuture&lt;List&lt;String&gt;&gt; getUsernames(String prefix);
</code></pre>
<a class="header" href="#follow-requests" id="follow-requests"><h1>Follow requests</h1></a>
<p>A user's storage server stores their pending follow requests until they are retrieved and deleted. These are not actually stored in ipfs itself, and reading them is guarded by a challenge protocol to mitigate against someone logging them alll now and decrypting them with a large quantum computer when one is built.</p>
<p>Follow requests contain no unencrypted data visible to the network, or server, apart from the target user. Only the target user can decrypt the follow request to see the sender.</p>
<p>The interface for sending, receiving and removing follow requests is called SocialNetwork and has the following methods:</p>
<pre><code class="language-java">/** Send a follow request to the target public key
 *
 * @param target The public identity key hash of the target user
 * @param encryptedPermission The encrypted follow request
 * @return True if successful
 */
CompletableFuture&lt;Boolean&gt; sendFollowRequest(PublicKeyHash target, byte[] encryptedPermission);

/**
 *
 * @param owner The public identity key hash of user who's pending follow requests are being retrieved
 * @param signedTime The current time signed by the owner
 * @return all the pending follow requests for the given user
 */
CompletableFuture&lt;byte[]&gt; getFollowRequests(PublicKeyHash owner, byte[] signedTime);

/** Delete a follow request for a given public key
 *
 * @param owner The public identity key hash of user who's follow request is being deleted
 * @param data The original follow request data to delete, signed by the owner
 * @return True if successful
 */
CompletableFuture&lt;Boolean&gt; removeFollowRequest(PublicKeyHash owner, byte[] data);
</code></pre>
<a class="header" href="#security" id="security"><h1>Security</h1></a>
<p>Peergos' primary focus is security.</p>
<a class="header" href="#trust-free-levels" id="trust-free-levels"><h1>Trust free levels</h1></a>
<p>Peergos is designed at every level to minimise or remove entirely any need for trust.</p>
<p>The first trust barrier is between Peergos and IPFS. A Peergos server verifies the hash of everything written to or read from IPFS. This removes the possibility of tampering at the ipfs level.</p>
<p>The second trust free barrier is between a Peergos client and a Peergos server. A Peergos client verifies the hash of every block read from or written to a Peergos server. Peergos clients also verify the signature of every signed piece of data received from Peergos. This means that once you have obtained a trustworthy copy of a Peergos client you do not need to trust a server to interact with it. </p>
<a class="header" href="#threat-models" id="threat-models"><h1>Threat models</h1></a>
<p>Peergos supports several threat models depending on the user and their situation.</p>
<a class="header" href="#casual-user" id="casual-user"><h2>Casual user:</h2></a>
<ul>
<li>Trusts the SSL certificate hierarchy and the domain name system</li>
<li>Is happy to run Javascript in their browser</li>
<li>Trusts TLS and their browser (and OS and CPU ;-) )</li>
</ul>
<p>Such a user can interact with peergos purely through a public web server that they trust over TLS.</p>
<a class="header" href="#slightly-paranoid-user" id="slightly-paranoid-user"><h2>Slightly paranoid user:</h2></a>
<ul>
<li>Doesn't trust DNS or SSL certificates</li>
<li>Is happy to run Javascript served from localhost in their browser</li>
</ul>
<p>This class of user can download and run the Peergos application and access the web interface through their browser over localhost.</p>
<a class="header" href="#more-paranoid-user" id="more-paranoid-user"><h2>More paranoid user:</h2></a>
<ul>
<li>Doesn't not trust the SSL certificate system</li>
<li>Doesn't trust DNS</li>
<li>Doesn't trust javascript</li>
</ul>
<p>This class of user can download the Peergos application (or otherwise obtain a signed copy), or build it from source. They can then run Peergos locally and use the native user interface, either the comand line or a FUSE mount. Once they have obtained or built a copy they trust, then they need trust only the integrity of TweetNacl cryptography (or our post-quantum upgrade) and the Tor architecture.  </p>
<a class="header" href="#login" id="login"><h1>Login</h1></a>
<p>To login your password + username + public salt are hashed using <a href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> hashing function (with parameters 17, 8, 1, 64). The output of this is your login keypair and a symmetric key. The login keypair is used to auth with your server and retrieve your encrypted login data, which is decrypted using the aforementioned symmetric key. The login data contains your identity keypair, social keypair, and the root capability to your filesystem.</p>
<p><img alt="Login key derivation" src="/img/login.png" class="center" style="width: 70%;" /></p>
<a class="header" href="#encryption" id="encryption"><h1>Encryption</h1></a>
<p>All your files are encrypted symmetrically with a random 256-bit key using salsa20+poly1305 (from TweetNaCl). These keys are not derived from the contents of the file (as some services do) because this leaks to the network which files you are storing. Files are split into chunks of up to 5 MiB and each chunk is independently encrypted, and optionally erasure coded. The link from one chunk of a file to the next is also encrypted so that the network cannot deduce how big an individual file is from the data at rest. </p>
<a class="header" href="#block-access-control" id="block-access-control"><h1>Block Access Control</h1></a>
<p>When an app on IPFS wants a block of data, it asks IPFS for the data corresponding to its content identifier, or <a href="https://docs.ipfs.io/concepts/content-addressing/#identifier-formats">CID</a> (basically, a hash of the data). IPFS will then search the global IPFS network for nodes that have this CID. At the same time, it will ask any nodes it's already in contact with: &quot;Do you have this CID?&quot;. Any contacted node that has the block can respond with the data. A nice property of this is that any node that has the content can serve it up, which means that it autoscales to demand.</p>
<p><center>
<img src="/img/bitswap-authed.png" alt="authed" />
<br/>
Authed bitswap retrieving a block.
</center></p>
<p>We have extended this protocol to have an optional auth string paired with every CID. In Peergos, this auth string is an <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html">S3 V4 signature</a>, which is time-limited, includes the CID, and is tied to the requesting node's public key (to prevent replay attacks). A replay attack would be if it were possible for someone without the block, who we had sent a valid auth token, to retrieve the block themselves directly using the token. As an anology, consider a ticketed event. If someone buys a ticket, and then a friend of theirs copies the ticket and uses that to gain entry, that is a replay attack. If, however, the tickets included the buyer's name on the ticket (they were non-transferable) and the event verified the holder's name on entry then the friend couldn't get in, even with the original ticket.</p>
<p>We do a similar thing to avoid this by using the source node's public key as the domain in the S3 request. This way we can broadcast a cid and auth string to the network and no one but us can use that auth string. The S3 V4 signature scheme is essentially repeated <a href="https://en.wikipedia.org/wiki/HMAC">hmac-sha256</a> and needs a secret key to function. Such a secret key would grant the holder access to the block, so we call it a Block Access Token or BAT for short, and each is 32 bytes long. Since it only depends on hmac-sha256, which itself only depends on sha256, it is post-quantum - a large quantum computer does not break it.</p>
<p>The primary BAT used for this authentication is derived from the block itself. This means any instance that retrieves such a block (after being authorised) can continue to serve it up and enforce the same access control, thus maintaining the autoscaling properties in a privacy-preserving way.</p>
<p>There are two formats of blocks in Peergos, cbor and raw. Raw blocks are the most sensitive (they hold users' encrypted data) and are just fragments of ciphertext with no additional structure. Cbor blocks are valid <a href="https://ipld.io/docs/codecs/known/dag-cbor/">dag-cbor</a> structured IPLD objects which can reference other blocks. How could we put a BAT in these blocks? In a cbor block, it is easy to choose a canonical place to put a list of BATs. If the cbor is a map object, we put a list of BATs at the top level under the key &quot;bats&quot;.</p>
<p><center>
<img src="/img/cbor-bats.png" alt="cbor-block-auth" />
<br/>
Structure for storing BATs in cbor blocks
</center></p>
<p>For raw objects, it is a little more difficult, as we also need to support raw blocks that do not have a BAT (either legacy blocks or ones specifically made public). Our design uses a detectable prefix of 8 FIXED bytes followed by a cbor list of BATs before the actual ciphertext of the block.</p>
<p><center>
<img src="/img/raw-bats.png" alt="raw-bock-auth" />
<br/>
Structure for storing BATs in the prefix of a raw block
</center></p>
<p>We normally have two bats per block. One is inline - and specific to that block only. The other is a user wide &quot;mirror&quot; BAT - and referenced in the block by its hash. The mirror BAT is for when a user wants to mirror all their data on another instance, or migrate to another instance.</p>
<table><thead><tr><th> </th><th> Chunk 1                </th><th>  Chunk 2     </th><th> Chunk 3 </th></tr></thead><tbody>
<tr><td> BAT stream secret </td><td> Sb (encrypted in base data)  </td><td>                    </td><td>    </td></tr>
<tr><td> BAT[] (unencrypted in root cbor object under &quot;bats&quot;) </td><td> B1=randomBytes(32)                </td><td> B2=hash(Sb + B1) </td><td> B3=hash(Sb + B2) </td></tr>
</tbody></table>
<p><center>
BAT derivation for subsequent chunks of a file
</center></p>
<p>Each 5 MiB chunk of a file or directory has its own unique BAT, so the server still cannot link the different blocks of a file to deduce the padded size of the file. Subsequent chunk BATs within a file are derived in the same way as we do the CHAMP labels, by hashing the current chunk BAT with a stream-secret, stored encrypted in the first chunk. This maintains our ability to seek within arbitrarily large files without any IO operations (just local hashing and then a final lookup of the requested chunk). When someone's access to a file or directory is revoked, the BATs are also changed, making it impossible to retrieve the new ciphertext even with previous access.</p>
<a class="header" href="#access-control" id="access-control"><h1>Access control</h1></a>
<p>Read access to your files is controlled by a data structure called cryptree, which is essentially a tree of symmetric keys, where the holder of one key can decrypt all the descendant keys. The result is extremely fine grained access control. You can grant access to someone to a file and that user won't be able to see any of the sibling files in the same folder (or even their names - or even their labels in the champ). Granting read access to a folder implies granting read access to all the contents of the folder recursively.</p>
<p><img alt="Read access capability tree" src="/img/read-cryptree.svg" class="center" style="width: 100%;" /></p>
<p>Write access is independently controlled by a similar, but simpler cryptree. All updates to a given subtree are signed by a corresponding writing key pair. When you grant write access to a file or folder then that item is moved to a new writing key pair, to keep the fine grained access control applicable to write access too. This operates independently of the read access control cryptree.</p>
<p><img alt="Write access capability tree" src="/img/write-cryptree.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#metadata" id="metadata"><h1>Metadata</h1></a>
<p>All of the metadata for a given file is encrypted, with a different symmetric key from the file itself. This includes the name for directories and also the filesize, modification time, any thumbnail and mime type for files. The size of files is further hidden by splitting files into 5MiB chunks and storing each chunk under a random label (along with those for all other files owned by the same user and controlled by the same writing key pair).</p>
<p>The metadata around access patterns will be hidden by hosting files behind a tor hidden service once Tor is integrated. This will ensure that when one user reads a file shared with them by a friend this access does not leak to the network the fact that they are friends. </p>
<a class="header" href="#quantum-resistance" id="quantum-resistance"><h1>Quantum resistance</h1></a>
<p>Peergos aims to be a long term secure file storage system, and hence we have architected it with an awareness of quantum computer based attacks (many of us are ex physicists).</p>
<p>Files that you store but don't share with anyone are already resistant to quantum computer based attacks. This is because the process from logging in to decrypting them only involves hashing and symmetric encryption, neither of which are significantly weakened by a quantum computer.</p>
<p>Files that have been shared are currently vulnerable to a quantum computer attack because they use asymmetric elliptic curve cryptography (Curve25519) to share the decryption capability. However, we plan to upgade to a suitable post-quantum algorithm soon. </p>
<a class="header" href="#social-graph" id="social-graph"><h1>Social graph</h1></a>
<p>Following a user is implemented by them sharing read access to a directory in their filesystem. The read capability is sent encrypted from a random single use keypair to the target user's public key. These requests will be sent over Tor to that user's hidden service to hide the metadata from the network. Once retrieved, the receiving user stores the capability in their own storage, symmetrically encrypted and deletes the follow request from their server. </p>
<a class="header" href="#public-key-infrastructure" id="public-key-infrastructure"><h1>Public Key Infrastructure</h1></a>
<p>All users have a public identity key, and these are stored in a merkle-champ. This structure is mirrored by all nodes (and will eventually be sharded). This includes the user's claim to a username along with an expiry, and their current storage server. The effect is similar to certificate transparency logs.</p>
<p>This allows users to do public key lookups without leaking to the network who they are looking up. Users also store the keys of their friends in their own filesystem in a TOFU setup. This means that ordinary usage doesn't involve looking up keys from the public blockchain. </p>
<a class="header" href="#how-does-it-work" id="how-does-it-work"><h1>How does it work?</h1></a>
<p>This section goes into technical detail about how different operations work in Peerogs. </p>
<a class="header" href="#signing-up" id="signing-up"><h1>Signing up</h1></a>
<p>The steps involved in signing up are:</p>
<ol>
<li>
<p>Register the username</p>
<ul>
<li>Hash the password and username through scrypt to get the identity key pair, following key pair and symmetric root key.</li>
<li>Generate a signed username claim including an expiry, and the ipfs node id of the storage server (the server we are signing up through) This is just identity.sign(username, expiry, [storage id])</li>
<li>Send this claim to the pki node for confirmation</li>
</ul>
</li>
<li>
<p>Set up your identity</p>
<ul>
<li>Write the public identity key to ipfs</li>
<li>Write the public following key to ipfs</li>
<li>Create a <a href="/architecture/writer.html">WriterData</a> for the identity key pair with the two resulting public key hashes</li>
<li>Generate a random key pair to control writes to the users filesystem. Add this key pair as an owned key to the identity WriterData.</li>
<li>Commit the identity WriterData (write it to ipfs and set the mutable pointer for the identity key pair to the resulting hash).</li>
</ul>
</li>
<li>
<p>Set up your filesystem</p>
<ul>
<li>Create a DirAccess <a href="/security/cryptree.html">cryptree</a> node for the user's root directory, and add this to the champ of the filesystem key pair.</li>
<li>Add a write capability (encrypted) to the static data section of the identity key pair's WriterData</li>
<li>Create the /username/shared directory which is used when sending follow requests</li>
</ul>
</li>
</ol>
<a class="header" href="#uploading-a-file" id="uploading-a-file"><h1>Uploading a file</h1></a>
<p>A file upload proceeds in the following steps</p>
<ol>
<li>
<p>Check filename is valid and free</p>
</li>
<li>
<p>Create a transaction file with a plan for the upload</p>
</li>
<li>
<p>For every section of the file which is up to 5 MiB:</p>
<ul>
<li>Encrypt the 5 MiB file section with a random symmetric key</li>
<li>Split the cipher text into 128 KiB fragments</li>
<li>Create a FileAccess cryptree node with merkle links to all the resulting fragments and an encrypted link to the next section (even if there isn't a next section)</li>
<li>Add the FileAccess to the champ of the writing key pair under a random 32 byte label</li>
</ul>
</li>
<li>
<p>Add a cryptree link from the parent directory to the file</p>
</li>
<li>
<p>Delete the transaction file</p>
</li>
</ol>
<p>A modification, such as uploading a file, can be done through any Peergos server as the writes are <a href="/dev/proxy.html">proxied</a> through an ipfs p2p stream to the owner's storage ipfs node.</p>
<a class="header" href="#sending-a-follow-request" id="sending-a-follow-request"><h1>Sending a follow request</h1></a>
<p>Sending a follow request proceeds in the following steps:</p>
<ol>
<li>
<p>Look up the target friend's public following key</p>
</li>
<li>
<p>Create a directory /our-name/shared/friend-name</p>
</li>
<li>
<p>Encrypt a read capability for that directory using a random key pair to the target's following key. Using a random keypair ensures that noone but the target friend can see who sent the request.</p>
</li>
<li>
<p>Send the follow request to the storage server of the target friend</p>
</li>
</ol>
<p>The target can then either allow and reciprocate (full bi-directional friendship), allow (you are following them), reciprocate (they are following you) or deny. If they have reciprocated then you can grant read or write access to any file or folder by adding a read or write capability in their directory in your space.</p>
<p>When you receive a follow request and either allow or reciprocate it then you add the capability in the request to your static data on your identity WriterData, so you can find it again later, before deleting the follow request from your server. </p>
<a class="header" href="#proxying-requests" id="proxying-requests"><h1>Proxying requests</h1></a>
<p>Any modifying request needs to be proxied to the correct destination server. This could be signing up, uploading a file, or sending a follow request. This is achieved using an ipfs p2p stream. In particular, because all these requests are http requests, we use the http p2p proxy exposed locally on the ipfs gateway. It means we can send any request to</p>
<p>http://localhost:8080/p2p/$target_node_id/http/$path</p>
<p>and it will go through an end to end encrypted stream through the ipfs network to the destination node, which then sends it to the local Peergos server at:</p>
<p>http://localhost:8000/$path</p>
<p>This is illustrated below:
<img alt="Proxying a request through ipfs" src="/img/proxy.svg" class="center" style="width: 100%;" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
