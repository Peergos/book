<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="overview/overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li><a href="overview/what_is_peergos.html"><strong aria-hidden="true">1.1.</strong> What is Peergos</a></li><li><a href="overview/aims.html"><strong aria-hidden="true">1.2.</strong> Aims</a></li></ol></li><li><a href="features/features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li><ol class="section"><li><a href="features/self.html"><strong aria-hidden="true">2.1.</strong> Self hosting</a></li><li><a href="features/p2p.html"><strong aria-hidden="true">2.2.</strong> Peer-to-peer</a></li><li><a href="features/multi.html"><strong aria-hidden="true">2.3.</strong> Multi-device login</a></li><li><a href="features/web.html"><strong aria-hidden="true">2.4.</strong> Web interface</a></li><li><a href="features/social.html"><strong aria-hidden="true">2.5.</strong> Social</a></li><li><a href="features/sharing.html"><strong aria-hidden="true">2.6.</strong> Sharing</a></li><li><a href="features/large.html"><strong aria-hidden="true">2.7.</strong> Large files</a></li><li><a href="features/streaming.html"><strong aria-hidden="true">2.8.</strong> Streaming</a></li><li><a href="features/viewers.html"><strong aria-hidden="true">2.9.</strong> File viewers</a></li><li><a href="features/public.html"><strong aria-hidden="true">2.10.</strong> Public links</a></li><li><a href="features/migration.html"><strong aria-hidden="true">2.11.</strong> Migration</a></li><li><a href="features/sync.html"><strong aria-hidden="true">2.12.</strong> File Sync</a></li><li><a href="features/open.html"><strong aria-hidden="true">2.13.</strong> Open source</a></li></ol></li><li><a href="architecture/architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li><ol class="section"><li><a href="architecture/logical.html"><strong aria-hidden="true">3.1.</strong> Logical</a></li><li><a href="architecture/physical.html"><strong aria-hidden="true">3.2.</strong> Physical</a></li><li><a href="architecture/immutable.html"><strong aria-hidden="true">3.3.</strong> Immutable data</a></li><li><a href="architecture/mutable.html"><strong aria-hidden="true">3.4.</strong> Mutable pointers</a></li><li><a href="architecture/writer.html"><strong aria-hidden="true">3.5.</strong> Writing subspaces</a></li><li><a href="architecture/champ.html"><strong aria-hidden="true">3.6.</strong> Merkle-CHAMP</a></li><li><a href="architecture/pki.html"><strong aria-hidden="true">3.7.</strong> Usernames</a></li><li><a href="architecture/follow.html"><strong aria-hidden="true">3.8.</strong> Follow requests</a></li></ol></li><li><a href="security/security.html"><strong aria-hidden="true">4.</strong> Security</a></li><li><ol class="section"><li><a href="security/threats.html"><strong aria-hidden="true">4.1.</strong> Threat models</a></li><li><a href="security/login.html"><strong aria-hidden="true">4.2.</strong> Login</a></li><li><a href="security/encryption.html"><strong aria-hidden="true">4.3.</strong> Encryption</a></li><li><a href="security/cryptree.html"><strong aria-hidden="true">4.4.</strong> Access control</a></li><li><a href="security/meta.html"><strong aria-hidden="true">4.5.</strong> Metadata</a></li><li><a href="security/quantum.html"><strong aria-hidden="true">4.6.</strong> Quantum resistance</a></li><li><a href="security/social.html"><strong aria-hidden="true">4.7.</strong> Social graph</a></li><li><a href="security/tofu.html"><strong aria-hidden="true">4.8.</strong> TOFU</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#the-peergos-private-social-network" id="the-peergos-private-social-network"><h1>The Peergos private social network</h1></a>
<p>The social network where you are in control.</p>
<a class="header" href="#what-is-peergos" id="what-is-peergos"><h1>What is Peergos</h1></a>
<p>You can think of Peergos as a cross between Dropbox, email, Facebook, Youtube and Twitter, but fully end-to-end encrypted and decentralised to keep your data and social graph private.</p>
<p>Peergos is a peer-to-peer encrypted filesystem with secure sharing of files designed to be resistant to surveillance of data content or friendship graphs. It will have a secure email replacement, with some interoperability with email. There will also be a totally private and secure social network, where users are in control of who sees what (executed cryptographically).</p>
<p>The name Peergos comes from the Greek word Πύργος (Pyrgos), which means stronghold or tower, but phonetically spelt with the nice connection to being peer-to-peer. It is pronounced peer-goss, as in gossip.</p>
<p><strong>WARNING:</strong> Peergos is still alpha software, and needs an independent security audit. Don't use it for data you can't afford to lose or expose, yet. Some of the features in this documentation are yet to be imlemented, in particular, Tor is not used yet. </p>
<a class="header" href="#aims" id="aims"><h1>Aims</h1></a>
<ul>
<li><strong>Securely</strong> and <strong>privately</strong> store files in a peer to peer network which has no central node and is generally difficult to disrupt or surveil</li>
<li><strong>Secure sharing</strong> of such files with other users of the network without visible meta-data (who shares with who)</li>
<li><strong>Beautiful user interface</strong> that any computer or mobile user can understand</li>
<li><strong>Secure messaging</strong>, with optional interop with actual email</li>
<li><strong>Independent</strong> of the central SSL CA trust architecture, and the domain name system</li>
<li><strong>Self hostable</strong> - A user should be able to easily run Peergos on a machine in their home and get their own Peergos storage space, and social communication platform from it</li>
<li>Secure web interface as well as desktop clients, and native folder sync</li>
<li>Enable users to collaborate, editing a document in place concurrently</li>
<li>Secure real time chat, and eventually realtime video chat</li>
<li>Plausibly deniable dual login to an account, ala Truecrypt</li>
<li>Optional use of U2F for securing login</li>
</ul>
<a class="header" href="#features" id="features"><h1>Features</h1></a>
<ul>
<li>Self hosting</li>
<li>Peer-to-peer</li>
<li>Multi-device login</li>
<li>Web interface</li>
<li>Social</li>
<li>Sharing</li>
<li>Large files</li>
<li>Streaming</li>
<li>File viewers</li>
<li>Public links</li>
<li>Migration</li>
<li>Folder Sync</li>
<li>Open source</li>
</ul>
<a class="header" href="#self-hosting" id="self-hosting"><h1>Self hosting</h1></a>
<p>Peergos is fully self hostable. You can run peergos from your own home or server to obtain as much storage and bandwidth as you need, whilst still transparently interacting with anyone using any other server. Because the server only ever sees encrypted data you can also tell it to directly store your data in a standard cloud storage provider like Backblaze or Amazon without any loss of privacy.</p>
<p><img alt="Self host at home or on your own server" src="/img/self-host.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#peer-to-peer" id="peer-to-peer"><h1>Peer-to-peer</h1></a>
<p>Peergos is built with a peer-to-peer architecture to protect against censorship and surveillance and to improve resiliency. There is no central surveillance point that an attacker could monitor all file transfers through. There is also no central dns name or TLS certificate authority that could be used to attack the network.</p>
<p><img alt="Peergos has a peer-to-peer architecture" src="/img/p2p.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#multi-device-login" id="multi-device-login"><h1>Multi-device login</h1></a>
<p>Peergos is naturally mutli-device. You can log in to your account from any device, and through any Peergos server. It is not tied to any other data like your phone number or email address. All you need is your username and your password. Any modern browser will suffice, including mobile.</p>
<p><img alt="Login through any device with a web browser" src="/img/multi-device.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#web-interface" id="web-interface"><h1>Web interface</h1></a>
<p>In keeping with our aim to be as convenient to use as existing centralised services, Peergos has a web interface which can be used instead of a native application. This interface does not require any special knowledge, especially not of cryptography or keys, but should none-the-less encourage/enforce safe practices. The web interface does not load any code from third-party servers and is entirely self hosted. You even load it directly from ipfs and log in!</p>
<p>The web interface can be accessed from a public server over https or from your machine if you run Peergos locally. </p>
<a class="header" href="#social" id="social"><h1>Social</h1></a>
<p>Peergos users can send follow requests to each other. If accepted, the other user can then share files or send messages with you. Following is a one-way mechanism: If Agata follows Bartek then Bartek can share files with Agata. If Bartek is also following Agata, then she can also share files with Bartek. Following can be revoked by either user at any point.</p>
<p>Your friend list is kept encrypted in your own Peergos space, hidden from other users and the server.</p>
<p>There is also a public link mechanism for sharing files with people who do not have peergos accounts. </p>
<a class="header" href="#sharing" id="sharing"><h1>Sharing</h1></a>
<p>A file or folder can be shared with any user who is following you. This access can be read only or writable. Access can be revoked at any time whilst maintaining access to anyone else the item is shared with. This is all achieved cryptographically with capabilities and lazy re-encryption. </p>
<a class="header" href="#large-files" id="large-files"><h1>Large files</h1></a>
<p>There is no file size limit in Peergos apart from what will fit in your storage quota. Despite doing client side encryption/decryption we can still upload or download arbitrarily large files sending directly from/to the filesystem. </p>
<a class="header" href="#streaming" id="streaming"><h1>Streaming</h1></a>
<p>Peergos is naturally streaming and despite having to decrypt files in the client we can still stream large files directly with low ram usage. This allows us to stream large videos in the browser directly to a html5 video element. </p>
<a class="header" href="#file-viewers" id="file-viewers"><h1>File viewers</h1></a>
<p>There are several built-in file viewers in Peergos. We have media viewers for images, videos and audio, as well as a text viewer and a raw hex viewer. In the future we hope to add pdf and other document viewers and also editors. </p>
<a class="header" href="#public-links" id="public-links"><h1>Public links</h1></a>
<p>Any file or folder can generate a public link to itself. Anyone with a (Javascript enabled) web browser can view such a link. This is a capability based link which includes the necessary key in the hash fragment of the url. Despite the name, a public link doesn't expose the file to the network, or indeed to anyone who doesn't have the link itself.</p>
<p>An example of a public link to a folder is:</p>
<p><a href="https://demo.peergos.net/#pQd8rmrEhBN1RbDLK1ioBnFF4YLgvPAmte3ypNDiwshMJJip9Dbbgw4t/FGXm4KWWePPNfdN91MNCeHgC16Wxemt4C4iDoS6qz1ea/5Pf7SvpL6BKtVUnPGmU3CqpZJ1hypK17GZbF27Ui8hKa2CXZWZZ">https://demo.peergos.net/#pQd8rmrEhBN1RbDLK1ioBnFF4YLgvPAmte3ypNDiwshMJJip9Dbbgw4t/FGXm4KWWePPNfdN91MNCeHgC16Wxemt4C4iDoS6qz1ea/5Pf7SvpL6BKtVUnPGmU3CqpZJ1hypK17GZbF27Ui8hKa2CXZWZZ</a></p>
<a class="header" href="#migration" id="migration"><h1>Migration</h1></a>
<p>Your identity in Peergos is not tied to any particular server. Compared to other federated social networks where moving server typically involves losing your social network and meta-data, if not data too, Peergos allows you to transparently migrate between servers and storage providers without any action required from your friends and without any data loss.</p>
<p>This means, for example, you could start out by creating an account on our demo server which gives you a small amount of storage, then effortlessly migrate to a paid server, or to your own server when you realise how awesome Peergos is. </p>
<a class="header" href="#file-sync" id="file-sync"><h1>File Sync</h1></a>
<p>Peergos has the ability to do standard directory syncing and transparently mount a folder to your host operating system. This is achieved with a FUSE binding (or equivalent for Windows and MacOS). </p>
<a class="header" href="#open-source" id="open-source"><h1>Open source</h1></a>
<p>Peergos is fully open-source, both clients, and server (incuding the web-interface).</p>
<p>No part of our infrastructure, apart from TLS and Peergos private keys, are secret. We also have reproducible builds (we don't use npm or browserify etc.) We also vendor all dependencies so any historic git commit should be buildable without any external data.</p>
<p>Eventually we want to self host our git repos in Peergos itself. </p>
<a class="header" href="#peergos-architecture" id="peergos-architecture"><h1>Peergos architecture</h1></a>
<a class="header" href="#logical" id="logical"><h1>Logical</h1></a>
<p>The logical architecture of Peergos consists of the following:</p>
<ol>
<li>Content addressed storage: a mapping from a hash to the (encrypted) data it is the hash of (the data store)</li>
<li>Mutable pointers: a mapping from a public key to a hash</li>
<li>PKI: a global append only log for the username &lt;==&gt; {identity public key, storage public key} mappings</li>
<li>Social: each user designates a server for sending follow requests for users to (the server can't see the source user). This is the same as the storage server for that user and is identified and contacted via its public key.</li>
</ol>
<p><img alt="Logical Architecture" src="/img/logical-arch.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#physical" id="physical"><h1>Physical</h1></a>
<p>Each user must have at least one Peergos server (which includes an instance of IPFS). This server stores their data, their mutable pointers and any pending follow requests for them. There is also the global append only log for the PKI which is mirrored on every node.</p>
<p><img alt="The physical architecture" src="/img/physical-arch.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#immutable-data" id="immutable-data"><h1>Immutable data</h1></a>
<p>The immutable data store is provided by IPFS and allows anyone to retrieve any cipher text from its hash through any Peergos node. Note that IPFS is used in a fully trustless manner. Every single hash and signature is checked client side during reads and writes. The underlying storage can be provided by the local harddisk or any cloud provider without loss of privacy.</p>
<p>The interface for this storage is call ContentAddressedStorage, with the following methods:</p>
<pre><code class="language-java">/**
 *
 * @return The identity (hash of the public key) of the storage node we are talking to
 */
CompletableFuture&lt;Multihash&gt; id();

/**
 *
 * @param owner
 * @return A new transaction id that can be used to group writes together and protect them from being garbage
 * collected before they have been pinned.
 */
CompletableFuture&lt;TransactionId&gt; startTransaction(PublicKeyHash owner);

/**
 * Release all associated objects from this transaction to allow them to be garbage collected if they haven't been
 * pinned.
 * owner
 * @param tid
 * @return
 */
CompletableFuture&lt;Boolean&gt; closeTransaction(PublicKeyHash owner, TransactionId tid);

/**
 *
 * @param owner The owner of these blocks of data
 * @param writer The public signing key authorizing these writes, which must be owned by the owner key
 * @param signatures The signatures of each block being written (by the writer)
 * @param blocks The blocks to write
 * @param tid The transaction to group these writes under
 * @return
 */
CompletableFuture&lt;List&lt;Multihash&gt;&gt; put(PublicKeyHash owner, PublicKeyHash writer, List&lt;byte[]&gt; signatures, List&lt;byte[]&gt; blocks, TransactionId tid);

/**
 *
 * @param hash
 * @return The data with the requested hash, deserialized into cbor, or Optional.empty() if no object can be found
 */
CompletableFuture&lt;Optional&lt;CborObject&gt;&gt; get(Multihash hash);

/**
 * Write a block of data that is just raw bytes, not ipld structured cbor
 * @param owner
 * @param writer
 * @param signatures
 * @param blocks
 * @param tid
 * @return
 */
CompletableFuture&lt;List&lt;Multihash&gt;&gt; putRaw(PublicKeyHash owner, PublicKeyHash writer, List&lt;byte[]&gt; signatures, List&lt;byte[]&gt; blocks, TransactionId tid);

/**
 * Get a block of data that is not in ipld cbor format, just raw bytes
 * @param hash
 * @return
 */
CompletableFuture&lt;Optional&lt;byte[]&gt;&gt; getRaw(Multihash hash);

/**
 * Update an existing pin with a new root. This is useful when modifying a tree of ipld objects where only a small
 * number of components are changed
 * @param owner The owner of the data
 * @param existing The present root hash
 * @param updated The new root hash
 * @return
 */
CompletableFuture&lt;List&lt;MultiAddress&gt;&gt; pinUpdate(PublicKeyHash owner, Multihash existing, Multihash updated);

/**
 * Recursively pin all the objects referenced via ipld merkle links from a root object
 * @param owner The owner of the data
 * @param hash The root hash of the merkle-tree
 * @return A list of the multihashes pinned
 */
CompletableFuture&lt;List&lt;Multihash&gt;&gt; recursivePin(PublicKeyHash owner, Multihash hash);

/**
 * Recursively unpin a merkle tree of objects. This releases the objects to be collected by garbage collection
 * @param owner The owner of the data
 * @param hash The root hash of the merkle-tree
 * @return
 */
CompletableFuture&lt;List&lt;Multihash&gt;&gt; recursiveUnpin(PublicKeyHash owner, Multihash hash);

/**
 * Get all the merkle-links referenced directly from this object
 * @param root The hash of the object whose links we want
 * @return A list of the multihashes referenced with ipld links in this object
 */
CompletableFuture&lt;List&lt;Multihash&gt;&gt; getLinks(Multihash root);

/**
 * Get the size in bytes of the object with the requested hash
 * @param block The hash of the object
 * @return The size in bytes, or Optional.empty() if it cannot be found.
 */
CompletableFuture&lt;Optional&lt;Integer&gt;&gt; getSize(Multihash block);
</code></pre>
<a class="header" href="#mutable" id="mutable"><h1>Mutable</h1></a>
<p>Mutable pointers in Peergos are just a mapping from a public key to a root hash. Clearly, being mutable, they need some kind of synchronization or concurrent data structure. Each user lists an ipfs node id (the hash of its public key) which is responsible for synchronising their writes and publishing the latest root hashes. This means the global filesystem is sharded by username and each user can use an ipfs instance (or cluster) with sufficient capability for their bandwidth requirements.</p>
<p>Initially each user's file system is under a single public key. Additional keys are generated when granting write access.</p>
<p>The interface for MutablePointers has the following methods:</p>
<pre><code class="language-java">/** Update the hash that a public key maps to (doing a cas with the existing value)
 *
 * @param owner The owner of this signing key
 * @param writer The public signing key
 * @param writerSignedBtreeRootHash the signed serialization of the HashCasPair
 * @return True when sucessfully completed
 */
CompletableFuture&lt;Boolean&gt; setPointer(PublicKeyHash owner, PublicKeyHash writer, byte[] writerSignedBtreeRootHash);

/** Get the current hash a public key maps to
 *
 * @param writer The public signing key
 * @return The signed cas of the pointer from its previous value to its current value
 */
CompletableFuture&lt;Optional&lt;byte[]&gt;&gt; getPointer(PublicKeyHash owner, PublicKeyHash writer);
</code></pre>
<a class="header" href="#writing-subspaces" id="writing-subspaces"><h1>Writing subspaces</h1></a>
<p>Each user has a randomly generated writing key pair which controls writes to their filesystem. They can create new writing key pairs for any subtree, for example when granting write access to a file or folder. If desired, a given writing key can be quota controlled, to prevent users to which you've granted write access to a file from filling your data store. </p>
<a class="header" href="#merkle-champ" id="merkle-champ"><h1>Merkle-CHAMP</h1></a>
<p>The main network visible data structure in Peergos is a merkle compressed hash array mapped trie, or merkle-champ. All the data under a given writing keypair has its own merkle-champ. This is just a mapping from random 32 byte labels to cipher-text blobs. These blobs are cryptree nodes containing the cryptree data structure, and, in the case of a file section, merkle links to encrypted file fragments. Each 5 MiB section of a file is stored under a different random label in the btree, and similarly with large directories.</p>
<p><img alt="the network visible merkle-champ" src="/img/champ.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#usernames" id="usernames"><h1>Usernames</h1></a>
<p>The public keys and usernames are stored in a global append only data structure, with names taken on a first come first served basis. This needs consensus to ensure uniqueness of usernames. This is also where the ipfs node id of the server(s) responsible for synchronising the user's writes is stored. The public key infrastructure (pki) server is called the Corenode, and its interface is the following.</p>
<pre><code class="language-java">/**
 *
 * @param username
 * @return the key chain proving the claim of the requested username and the ipfs node id of their storage
 */
CompletableFuture&lt;List&lt;UserPublicKeyLink&gt;&gt; getChain(String username);

/** Claim a username, or change the public key owning a username
 *
 * @param username
 * @param chain The changed links of the chain
 * @return True if successfully updated
 */
CompletableFuture&lt;Boolean&gt; updateChain(String username, List&lt;UserPublicKeyLink&gt; chain);

/**
 *
 * @param key the hash of the public identity key of a user
 * @return the username claimed by a given public key
 */
CompletableFuture&lt;String&gt; getUsername(PublicKeyHash key);

/**
 *
 * @param prefix
 * @return All usernames starting with prefix
 */
CompletableFuture&lt;List&lt;String&gt;&gt; getUsernames(String prefix);
</code></pre>
<a class="header" href="#follow-requests" id="follow-requests"><h1>Follow requests</h1></a>
<p>A user's storage server stores their pending follow requests until they are retrieved and deleted. These are not actually stored in ipfs itself, and reading them is guarded by a challenge protocol to mitigate against a future quantum computer.</p>
<p>Follow requests contain no unencrypted data visible to the network, or server, apart from the target user. Only the target user can decrypt the follow request to see the sender.</p>
<p>The interface for sending, receiving and removing follow requests is called SocialNetwork and has the following methods:</p>
<pre><code class="language-java">/** Send a follow request to the target public key
 *
 * @param target The public identity key hash of the target user
 * @param encryptedPermission The encrypted follow request
 * @return True if successful
 */
CompletableFuture&lt;Boolean&gt; sendFollowRequest(PublicKeyHash target, byte[] encryptedPermission);

/**
 *
 * @param owner The public identity key hash of user who's pending follow requests are being retrieved
 * @param signedTime The current time signed by the owner
 * @return all the pending follow requests for the given user
 */
CompletableFuture&lt;byte[]&gt; getFollowRequests(PublicKeyHash owner, byte[] signedTime);

/** Delete a follow request for a given public key
 *
 * @param owner The public identity key hash of user who's follow request is being deleted
 * @param data The original follow request data to delete, signed by the owner
 * @return True if successful
 */
CompletableFuture&lt;Boolean&gt; removeFollowRequest(PublicKeyHash owner, byte[] data);
</code></pre>
<a class="header" href="#security" id="security"><h1>Security</h1></a>
<p>Peergos' primary focus is security.</p>
<a class="header" href="#threat-models" id="threat-models"><h1>Threat models</h1></a>
<p>Peergos supports several threat models depending on the user and their situation.</p>
<a class="header" href="#casual-user" id="casual-user"><h2>Casual user:</h2></a>
<ul>
<li>Trusts the SSL certificate hierarchy and the domain name system</li>
<li>Is happy to run Javascript in their browser</li>
<li>Trusts TLS and their browser (and OS and CPU ;-) )</li>
</ul>
<p>Such a user can interact with peergos purely through a public web server that they trust over TLS.</p>
<a class="header" href="#slightly-paranoid-user" id="slightly-paranoid-user"><h2>Slightly paranoid user:</h2></a>
<ul>
<li>Doesn't trust DNS or SSL certificates</li>
<li>Is happy to run Javascript served from localhost in their browser</li>
</ul>
<p>This class of user can download and run the Peergos application and access the web interface through their browser over localhost.</p>
<a class="header" href="#more-paranoid-user" id="more-paranoid-user"><h2>More paranoid user:</h2></a>
<ul>
<li>Doesn't not trust the SSL certificate system</li>
<li>Doesn't trust DNS</li>
<li>Doesn't trust javascript</li>
</ul>
<p>This class of user can download the Peergos application (or otherwise obtain a signed copy), or build it from source. They can then run Peergos locally and use the native user interface. Once they have obtained or built a copy they trust, then they need trust only the integrity of TweetNacl cryptography (or our post-quantum upgrade) and the Tor architecture.  </p>
<a class="header" href="#login" id="login"><h1>Login</h1></a>
<p>Decentralised login is achieved using a capability based system. Your identity key pairs and root encryption key are derived from your password salted with your username and passed through the scrypt hashing function (with parameters 17, 8, 1, 96). By virtue of being decentralised, we cannot rate limit attempts to crack your password, so choosing a good passord is imperative. We recommend at least 14 random alphanumeric characters.</p>
<p><img alt="Login key derivation" src="/img/scrypt.svg" class="center" style="width: 70%;" /></p>
<a class="header" href="#encryption" id="encryption"><h1>Encryption</h1></a>
<p>All your files are encrypted symmetrically with a random 256-bit key using salsa20+poly1305 (from TweetNaCl). These keys are not derived from the contents of the file (as some services do) because this leaks to the network which files you are storing. Files are split into chunks of up to 5 MiB and each chunk is independently encrypted, and optionally erasure coded. The link from one chunk of a file to the next is also encrypted so that the network cannot deduce how big an individual file is from the data at rest. </p>
<a class="header" href="#access-control" id="access-control"><h1>Access control</h1></a>
<p>Read access to your files is controlled by a data structure called cryptree, which is essentially a tree of symmetric keys, where the holder of one key can decrypt all the descendant keys. The result is extremely fine grained access control. You can grant access to someone to a file and that user won't be able to see any of the sibling files in the same folder (or even their names - or even their labels in the champ). Granting read access to a folder implies granting read access to all the contents of the folder recursively.</p>
<p><img alt="Read access capability tree" src="/img/read-cryptree.svg" class="center" style="width: 100%;" /></p>
<p>Write access is independently controlled by a similar, but simpler cryptree. All updates to a given subtree are signed by a corresponding writing key pair. When you grant write access to a file or folder then that item is moved to a new writing key pair, to keep the fine grained access control applicable to write access too. This operates independently of the read access control cryptree.</p>
<p><img alt="Write access capability tree" src="/img/write-cryptree.svg" class="center" style="width: 100%;" /></p>
<a class="header" href="#metadata" id="metadata"><h1>Metadata</h1></a>
<p>All of the metadata for a given file is encrypted, with a different symmetric key from the file itself. This includes the name for directories and also the filesize, modification time, any thumbnail and mime type for files. The size of files is further hidden by splitting files into 5MiB chunks and storing each chunk under a random label (along with those for all other files owned by the same user and controlled by the same writing key pair).</p>
<p>The metadata around access patterns is hidden by hosting files behind a tor hidden service. This ensures that when one user reads a file shared with them by a friend this access does not leak to the network the fact that they are friends. </p>
<a class="header" href="#quantum-resistance" id="quantum-resistance"><h1>Quantum resistance</h1></a>
<p>Peergos aims to be a long term secure file storage system, and hence we have architected it with an awareness of quantum computer based attacks (many of us are ex physicists).</p>
<p>Files that you store but don't share with anyone are already resistant to quantum computer based attacks. This is because the process from logging in to decrypting them only involves hashing and symmetric encryption, neither of which are significantly weakened by a quantum computer.</p>
<p>Files that have been shared are currently vulnerable to a quantum computer attack because they use asymmetric elliptic curve cryptography (Curve25519) to share the decryption capability. However, we plan to upgade to a suitable post-quantum algorithm soon. </p>
<a class="header" href="#social-graph" id="social-graph"><h1>Social graph</h1></a>
<p>Following a user is implemented by them sharing read access to a directory in their filesystem. The read capability is sent encrypted from a random single use keypair to the target user's public key. These requests are sent over Tor to that user's hidden service to hide the metadata from the network. Once retrieved, the receiving user stores the capability in their own storage, symmetrically encrypted and deletes the follow request from their server. </p>
<a class="header" href="#tofu" id="tofu"><h1>TOFU</h1></a>
<p>All users have a public identity key, and these are stored in an append only content addressed data structure (or blockchain if you will). This structure is mirrored by all nodes. This allows users to do public key lookups without leaking to the network who they are looking up. Users also store the keys of their friends in their own filesystem in a TOFU setup. This means that ordinary usage doesn't involve looking up keys from the public blockchain. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
